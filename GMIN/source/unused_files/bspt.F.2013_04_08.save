!  GMIN: A program for finding global minima
!
!  Copyright (C) 1999-2006 David J. Wales
!  This file is part of GMIN.
!
!  GMIN is free software; you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation; either version 2 of the License, or
!  (at your option) any later version.
!
!  GMIN is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.
!
!  You should have received a copy of the GNU General Public License
!  along with this program; if not, write to the Free Software
!  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
!
! 
!---======================================---
      SUBROUTINE PTBASINSAMPLING
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This subroutine implements 
!  
!  1. PTMC or MC Replica Exchange 
!  2. PTMC with Reservoir of Minima 
!  3. BSPT 
!
! MC trial move is all atom random cartesian perturbation. 
!
! Should be compiled with MPI. 
!
! Change history: 
!   04/09/201, ss2029:
!                 - MC step variable name changed from I to IMCSTEP 
!                 - implemented system time seeding for random number
!                 generator        
!                 - implemented keyword PTMCDUMPENER       
!                 - collecting and printing time taken per step 
!                 - several changes to output messages (e.g. end of
!                 equi, step size adjustment,.. )       
!                 - several explanatory comments and todo tasks!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      USE MODCHARMM
      USE COMMONS
      USE TETHERFUNC
      USE CLASS_OVERLAP
      IMPLICIT NONE
!
! The ifdef MPI is basically the whole subroutine.
!
#ifdef MPI
      INCLUDE 'mpif.h'
      !
      ! NHIST=100 and NHISTE=1000 were hardcoded. They are used to allocate huge arrays later on. Changing to small numbers for now. 
      !     todo - read from data file
      !
      INTEGER, PARAMETER :: NHIST=2, NHISTE=2
      INTEGER :: IACCEPT(0:NPAR-1), MPIERR, J,K, TEMPUNIT
      INTEGER NHISTQ4(NHIST,0:NPAR-1), NDUMMY, NDUMMY2, NTOT, NH, IQE, IQ4, IQ6, J1, J2, J3, J4, JLOW,
     1        NHISTQ6(NHIST,0:NPAR-1), NHISTQE(NHISTE, 0:NPAR-1), IENR, N1,
     2        NOUT(0:NPAR-1), ITRAJ, ITRAJO,NEACCEPT, RNDSEED, NUPDATE,
     3        CONVERGED,LBFGS_ITERATIONS, JD, BININDEX, MINIMANUMBER(HBINS,0:NPAR-1),
     4        NHISTALLQ(NHIST, NHIST, 0:NPAR-1), IBININDEX, IBININDEX2, LOWESTDIRECT(HBINS),
     5        NHISTGRAND(NHISTE, NHIST, NHIST, 0:NPAR-1),LBFGS_ITERATIONSO,LVISITS(NENRPER),PEVISITS2(NENRPER, HBINS, 0:NPAR-1),
     7        NOUTQBIN, NOUTPEBIN, LBFGS_ITERATIONSSAVE, HBINMAX, HBINMIN, GETUNIT, LUNIT
      DOUBLE PRECISION IMCSTEP, XOUT
      DOUBLE PRECISION QVISITS(HBINS, 0:NPAR-1), NACCEPTPT(0:NPAR-1)

      DOUBLE PRECISION PEVISITS(NENRPER,0:NPAR-1) ! instantaneous energy histogram from different replicas  

      DOUBLE PRECISION V(NATOMS), VO(NATOMS), TEMPTRAJ(0:NPAR-1), H(0:NPAR-1), BETA(0:NPAR-1), 
     1        EAV(0:NPAR-1), EAV2(0:NPAR-1), Q(3,NATOMS), Q4AV(0:NPAR-1), Q4AV2(0:NPAR-1), 
     2        Q6AV(0:NPAR-1), Q6AV2(0:NPAR-1), VENR(NENRPER), 
     3        HINIT(0:NPAR-1), X(NATOMS), Y(NATOMS), Z(NATOMS), 
     4        CTE, T, VOLD,VNEW, POTEL, GRAD(3*NATOMS), Q4, Q6, RANDOM, DPRAND, Q4MAX, Q6MAX , 
     5        DQ4, DQ6, DHISTE, ENUL, XO(NATOMS), YO(NATOMS), ZO(NATOMS), DDX, DDY, DDZ, DE, 
     6        W, WCOMP, WAC, E, CV, FQ4, FQ6, RMAX, DDXN, DDYN, DDZN, R2, 
     7        DUMMY,BINLABEL(HBINS), VNEWSAVE, DIHEORDERPARAM,SASAORDERPARAM, PEINT, HISTINT, 
     8        DIHEORDERPARAM_AV(0:NPAR-1), SASAORDERPARAM_AV(0:NPAR-1), MINCOORDS(3*NATOMS,NPAR), INTERIMCOORDS(3*NATOMS,1),
     9        INTERIMCOORDS2(3*NATOMS,1), DIST, DOSSTATS(MAXIT,2), DOSSTATSO(MAXIT,2), 
     A        DCOORDS(3*NATOMS), DOSSTATSDUM(MAXIT,2), SR3, OPOTEL,
     B        DPRAND_UNIVERSAL

       DOUBLE PRECISION DIHEORDERPARAM_MIN, DIHEORDERPARAM_MAX, SASAORDERPARAM_MIN, SASAORDERPARAM_MAX, 
     1          DDIHE, DSASA, RGYR_MIN, RGYR_MAX, EINT_MIN, EINT_MAX, DRGYR, DEINT,
     2          RGYR_AV(0:NPAR-1), EINT_AV(0:NPAR-1), RGYR_AV2(0:NPAR-1), EINT_AV2(0:NPAR-1),
     3          ORDERPARAM1, ORDERPARAM2, DISTANCE(HBINS, 0:NPAR-1),
     4          DISTANCE_AV(HBINS,0:NPAR-1), DISTANCEOLD, NORM_PJ(0:NPAR-1), PJ(HBINS,0:NPAR-1),
     5          VMINOLD, VMINNEW, DELTA_EAV(0:NPAR-1), CX, CY, CZ, LCOORDS(3*NATOMS),
     6          DIHEORDERPARAM_AV2(0:NPAR-1), SASAORDERPARAM_AV2(0:NPAR-1), RGYR, EINT, VMINNEWSAVE, CANDIDATEWEIGHT

      CHARACTER (LEN=256)  FILENAME, FILENAME2,FILENAME3,FILENAME4,FILENAME5,FILENAME6,
     1                      FILENAME7,FILENAME8,FILENAME9, FILENAME10, FILENAME11, FILENAME12, 
     2                      FILENAME100,FILENAME101,FILENAME102, FILENAME103, FILENAME104, FILENAME105,
     3                      FILENAME106, FILENAMEDUMMY
      CHARACTER (LEN=80)  ISTR, SDUMMY
      CHARACTER (LEN=80)  CFNAME
      LOGICAL FITS, NEWENERGY, EVAP, EVAPREJECT, RECOUNT, YESNO, OUTSIDE, JUMPT, EXCHANGEACCEPT
      LOGICAL PTMCDS_NEW, FILETEST
      DOUBLE PRECISION RRX,RRY,RRZ,RRR

      character(len=10)       :: datechar,timechar,zonechar
      integer                 :: values(8),ITIME

! <--ss2029 variables for writing markov energies from each replica 
      CHARACTER (LEN=256) FILENAME_ENER 
      INTEGER             FILENAME_ENER_LUNIT 
! ss2029--> 

      DOUBLE PRECISION PREVSTEPS, PFNORM1, PFNORM2, NORM1, NORM2
      DOUBLE PRECISION, ALLOCATABLE :: CANDIDATECRD(:,:,:), CANDIDATEPE(:,:), CANDIDATET(:,:)
      INTEGER, ALLOCATABLE :: CANDIDATENUM(:)
      INTEGER OVERLAP_UNIT, OVERLAP_COUNT, KAPPA
      CHARACTER (LEN=200)  OVERLAP_FNAME
      DOUBLE PRECISION TIMESTART, OVERLAP_TIMETOT
      DOUBLE PRECISION TIMESTART1, TIME2, MCSTEPSTART
      DOUBLE PRECISION OVERLAP_VALA, OVERLAP_VALB, OVERLAP_VALAB
      DOUBLE PRECISION OVERLAP_VAL2A, OVERLAP_VAL2B, OVERLAP_VAL2AB
      DOUBLE PRECISION OVERLAP_VAL2RA, OVERLAP_VAL2RB, OVERLAP_VAL2RAB
      DOUBLE PRECISION OVERLAP_VALQA, OVERLAP_VALQB, OVERLAP_VALQAB
      DOUBLE PRECISION OVERLAP_VALQ2A, OVERLAP_VALQ2B, OVERLAP_VALQ2AB
      DOUBLE PRECISION OVERLAP_VALQ2RA, OVERLAP_VALQ2RB, OVERLAP_VALQ2RAB
      LOGICAL NORESET_TEMP
      INTEGER EXAB_COUNT, EXAB_ACC

!     DOUBLE PRECISION PTCAND(PTSTEPS/10,3*NATOMS), PTCANDE(PTSTEPS/10)
      DOUBLE PRECISION PEQMIN(NRESMIN), QV(NENRPER), ZT, VZERO, THISV, PEQV(NENRPER), XDUMMY
      INTEGER PTCANDN, NGMIN, NCHOSEN
      DOUBLE PRECISION :: LASTEXUP(0:NPAR-1), LASTEXDOWN(0:NPAR-1)

      COMMON /MYPOT/ POTEL
      COMMON /EV/ EVAP, EVAPREJECT

      PTMCDS_NEW = .TRUE.
      EXAB_COUNT = 0
      EXAB_ACC = 0

      CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NDUMMY,MPIERR)
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,MYNODE,MPIERR)
      XOUT=0.0D0
      NOUTQBIN=0
      NOUTPEBIN=0
      LASTEXUP(0:NPAR-1)=-1.0D0
      LASTEXDOWN(0:NPAR-1)=-1.0D0
!
! Should remove the CANDIDATELISTT stuff when tidying up. DJW
!
      PTCANDN=PTSTEPS/10
      IF (CANDIDATELISTT) THEN
         ALLOCATE(CANDIDATECRD(3*NATOMS,NCANDIDATES,HBINS),CANDIDATENUM(HBINS),
     &            CANDIDATEPE(NCANDIDATES,HBINS),CANDIDATET(NCANDIDATES,HBINS))
         CANDIDATENUM(1:HBINS)=0
         CANDIDATEPE(1:NCANDIDATES,1:HBINS)=0.0D0
         CANDIDATET(1:NCANDIDATES,1:HBINS)=0.0D0
         CANDIDATECRD(1:3*NATOMS,1:NCANDIDATES,1:HBINS)=0.0D0
         WRITE(MYUNIT, '(A,F12.4)') 'bspt> Allocated storage for candidate configurations in Mb: ', 
     &        3*NATOMS*NCANDIDATES*HBINS*8.0D0/1.0D6
      ENDIF

      WRITE(MYUNIT, '(A,I10,A,I10)') "bspt> This is processor", MYNODE+1, " of", NPAR
      WRITE(MYUNIT, '(A,I10)') 'bspt> Number of atoms', natoms
      IF (FIXSTEP(1)) FIXSTEP(2:NPAR)=.TRUE.
      IF (FIXTEMP(1)) FIXTEMP(2:NPAR)=.TRUE.
      IF (PERIODIC) THEN
         WRITE(MYUNIT, '(A,6G20.10)') 'bspt> Binary data', ntypea, epsab, epsbb, sigab, sigbb, cutoff
         WRITE(MYUNIT, '(A,3G20.10)') 'bspt> Box data', boxlx, boxly, boxlz
      ELSEIF(CHRMMT) THEN
         WRITE(MYUNIT, '(A)') 'bspt> CHARMM job'
         IF (FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1)) THEN
            WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),' (fixed)'
         ELSEIF ((MYNODE.LE.USERES).AND.RESERVOIRT) THEN
            WRITE(MYUNIT, '(A)') 'bspt> Configurations will only be generated from the reservoir for exchange'
         ELSE
            WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize ', STEP(MYNODE+1),
     &                            ' (will be dynamically adjusted during equilibration)'
         ENDIF
      ELSEIF (.NOT.MODEL1T) THEN
         IF (PERCOLATET) THEN
            WRITE(MYUNIT, '(A,2G20.10)') 'bspt> Checking for a percolating system with threshold ',SQRT(PERCCUT)
         ELSE
            WRITE(MYUNIT, '(A,2G20.10)') 'bspt> Radius and Radius**2: ',SQRT(RADIUS),radius
         ENDIF
      ENDIF

      ITRAJ=MYNODE
      NEACCEPT=0
!     MINIMANUMBER=0 ! Number of distinct minima for quench bins in each replica. Not currently used.
      IENR=0 ! DJW APPEARED TO BE UNINITIALISED ?
!
! PEINT is the PE bin width.
!
      PEINT=(PTEMAX-PTEMIN)/NENRPER
      MAXEFALL=-1.0D100
      HISTINT=(HISTMAX-HISTMIN)/HBINS
      IF (MINDENSITYT.AND.(PTSTEPS*1.0D0.GT.0.0D0)) THEN
         WRITE(MYUNIT, '(A,2I8)') 'bspt> WARNING **** PTSTEPS reset to zero for density of minima run' 
         PTSTEPS=0
      ENDIF
!
! Limit for quench energy above which steps will be rejected.
!
!     HBINMAX=(MIN(BSPTQMAX,HISTMAX)-HISTMIN)/HISTINT+1
!     HBINMIN=(MAX(BSPTQMIN,HISTMIN)-HISTMIN)/HISTINT
      HBINMIN=1
      HBINMAX=HBINS
      WRITE(MYUNIT, '(A,2I8)') 'bspt> Minimum and maximum quench bin limits: ',HBINMIN,HBINMAX
      DO J1=1, HBINS
!        BINLABEL(J1)=HISTMIN + HISTINT*(J1-0.5D0) ! these energies point to the middle of the quench bin
         BINLABEL(J1)=HISTMIN + HISTINT*(J1-1.0D0) ! these energies point to the bottom of the quench bin
      ENDDO

!js850> 
      IF (OVERLAPK) THEN
        OVERLAP_COUNT = 0
        OVERLAP_UNIT=GETUNIT()
        WRITE(OVERLAP_FNAME,*) 'overlap.'
        WRITE(SDUMMY,'(I3)') MYNODE+1 
        OVERLAP_FNAME=TRIM(ADJUSTL(OVERLAP_FNAME)) // TRIM(ADJUSTL(SDUMMY))
        OPEN(UNIT=OVERLAP_unit,FILE=OVERLAP_FNAME, STATUS="unknown", form="formatted")
        WRITE(MYUNIT,'(A)') "bspt> overlap> IMCSTEP Qsum E Qsumquench Equench QA QB QexpA QexpB QexpAB" 
        WRITE(OVERLAP_UNIT,'(2A)') "#IMCSTEP, QAB, E, quenchQAB, Equench, QA, QB, QexpA, QexpB, QexpAB, quenchQexpA, ", 
     &         "quenchQexpB, quenchQexpAB Qexp2RA Qexp2RB Qexp2RAB quenchQexp2RA quenchQexp2RB quenchQexp2RAB"
      ENDIF

! Initialisation

      KAPPA=3*NATOMS-6
      DO J1=1,NATOMS
         X(J1)=COORDS(3*(J1-1)+1,MYNODE+1)
         Y(J1)=COORDS(3*(J1-1)+2,MYNODE+1)
         Z(J1)=COORDS(3*(J1-1)+3,MYNODE+1)
      ENDDO
      DO J1=1,NATOMS
         Q(1,J1)=X(J1)
         Q(2,J1)=Y(J1)
         Q(3,J1)=Z(J1)
      ENDDO

      CTE=(LOG(PTTMAX/PTTMIN))/(NPAR-1)
      CTE=EXP(CTE)

      DO J1=0, NPAR-1
         TEMPTRAJ(J1)=PTTMIN*CTE**J1
         T=TEMPTRAJ(J1)
         BETA(J1)=1.0D0/T
      ENDDO
     
      WRITE(MYUNIT, '(A, I4)') 'bspt> Coordinates and temperatures initialized for replica = ', MYNODE+1
     
!
! Bookkeeping is performed by node 0. 
!  Dump temperatures file and create directories named 1,..,Nrep (=NPAR)  
!
      IF (MYNODE.EQ.0) THEN
         LUNIT=GETUNIT()
         OPEN(UNIT=LUNIT, FILE='temperatures',STATUS='UNKNOWN')
         WRITE(LUNIT,'(G20.10)') TEMPTRAJ(0:NPAR-1)
         CLOSE(LUNIT)
         DO J1=1,NPAR
            WRITE(SDUMMY,'(A,I6,A)') 'mkdir ',J1,' >& /dev/null'
            CALL SYSTEM(SDUMMY)
         ENDDO
      ENDIF
!
! MPI synchronise to make sure that the directories have been created.
! Needed so that dumpenergy files can be opened in the directories.
! ss2029. 
!
      CALL MPI_BARRIER(MPI_COMM_WORLD,MPIERR)
!
! Nodes up to USERES could sample from a reservoir of local minima.
!
      IF ((MYNODE.EQ.USERES+1).AND.RESERVOIRT) THEN
         WRITE(MYUNIT,'(A,I12,A)') 'bspt> Visits will not be recorded for ',EXEQ,' steps after a successful reservoir exchange'
      ENDIF
      IF ((MYNODE.LE.USERES).AND.RESERVOIRT) THEN
         DO J1=1,NRESMIN
            IF (EMIN(J1).LT.VZERO) THEN
               VZERO=EMIN(J1)
               NGMIN=J1
            ENDIF
         ENDDO
         WRITE(MYUNIT,'(A,I6,A,G20.10)') 'bspt> Energy of lowest minimum number ',NGMIN,' is',VZERO
         WRITE(MYUNIT,'(A)') 'bspt> Calculating equilibrium occupation probabilities for lowest temperature image'
         DO J1=1,NRESMIN
            PFMIN(J1)= -EMIN(J1)/TEMPTRAJ(MYNODE) - FVIBMIN(J1)/2.0D0 - LOG(1.0D0*HORDERMIN(J1))
         ENDDO
         PFNORM1=0.0D0
         PFNORM2=0.0D0
         DO J1=1,NRESMIN
            PFNORM1=PFNORM1+EXP(-FVIBMIN(J1)/2.0D0 - LOG(1.0D0*HORDERMIN(J1)) 
     &                         + FVIBMIN(1)/2.0D0  + LOG(1.0D0*HORDERMIN(1)))
            PFNORM2=PFNORM2+EXP(PFMIN(J1)-PFMIN(1))
         ENDDO
         PFNORM1=LOG(PFNORM1)
         PFNORM2=LOG(PFNORM2)
!        IF (DEBUG) THEN
            WRITE(MYUNIT,'(A)') '     energy        pg order     high T/E prob       Peq'
            NORM1=0.0D0
            NORM2=0.0D0
            DO J1=1,NRESMIN
               WRITE(MYUNIT,'(F20.10,I6,2G20.10)') EMIN(J1),HORDERMIN(J1),
     &          EXP(-FVIBMIN(J1)/2.0D0 -LOG(1.0D0*HORDERMIN(J1))
     &             + FVIBMIN(1)/2.0D0 + LOG(1.0D0*HORDERMIN(1))-PFNORM1),
     &                   EXP(PFMIN(J1)-PFMIN(1)-PFNORM2)
               NORM1=NORM1+EXP(-FVIBMIN(J1)/2.0D0 -LOG(1.0D0*HORDERMIN(J1))
     &             + FVIBMIN(1)/2.0D0 + LOG(1.0D0*HORDERMIN(1))-PFNORM1)
               NORM2=NORM2+EXP(PFMIN(J1)-PFMIN(1)-PFNORM2)
            ENDDO
            WRITE(MYUNIT,'(A,2G20.10)') 'bspt> Check sums=',NORM1,NORM2
!        ENDIF
!
! Equilibrium occupation probabilities of the NRESMIN minima at this temperature,
! and equilibrium occupation probabilities of the PE bins for the given minima.
! Not used?
!
         DO J1=1,NRESMIN
            PEQMIN(J1)=EXP(PFMIN(J1)-PFMIN(1)-PFNORM2)
         ENDDO
!
! QV(J1) is the logarithm of the density of states at the potential
! energy corresponding to bin J1 at the temperature of the replica.
!
         XDUMMY=-HUGE(1.0D0)
         DO J1=1,NENRPER
            THISV=PTEMIN+(J1-0.5D0)*PEINT
            IF (THISV.GT.VZERO) THEN
               QV(J1)=(KAPPA/2.0D0-1.0D0)*LOG(THISV-VZERO)-FVIBMIN(NGMIN)/2.0D0-LOG(1.0D0*HORDERMIN(NGMIN))
!              WRITE(MYUNIT,'(A,I6,4G20.10)') 'J1, initial QV=',J1,QV(J1)
               DUMMY=0.0D0
               DO J2=1,NRESMIN
                  IF (THISV.GT.EMIN(J2)) THEN
                     DUMMY=DUMMY+EXP((FVIBMIN(NGMIN)-FVIBMIN(J2))/2.0D0)
     &                          *((1.0D0*HORDERMIN(NGMIN))/(1.0D0*HORDERMIN(J2)))
     &                          *((THISV-EMIN(J2))/(THISV-VZERO))**(KAPPA/2.0D0-1.0D0)
                  ENDIF
               ENDDO
               IF (DUMMY.GT.0.0D0) QV(J1)=QV(J1)+LOG(DUMMY)
            ELSE
               QV(J1)=-HUGE(1.0D0)
            ENDIF
         ENDDO
!
! Find the largest term in the partition function and use it to rescale
! everything.
!
         XDUMMY=-HUGE(1.0D0)
         DO J1=1,NENRPER
            THISV=PTEMIN+(J1-0.5D0)*PEINT
            DUMMY=QV(J1)-(THISV-VZERO)/TEMPTRAJ(MYNODE)
            IF (DUMMY.GT.XDUMMY) XDUMMY=DUMMY
         ENDDO
         ZT=0.0D0
         DO J1=1,NENRPER
            QV(J1)=QV(J1)-XDUMMY
            THISV=PTEMIN+(J1-0.5D0)*PEINT
            ZT=ZT+EXP(QV(J1)-(THISV-VZERO)/TEMPTRAJ(MYNODE))
         ENDDO
         ZT=LOG(ZT)
!        IF (DEBUG) WRITE(MYUNIT,'(A,G20.10)') 'bspt> ZT=',ZT
!
! ZT is the log of the partition function and PEQV(J1) is the 
! occupation probability of PE bin J1 at this temperature.
!
         NORM1=0.0D0
         DUMMY=-HUGE(1.0D0)
         DO J1=1,NENRPER
            THISV=PTEMIN+(J1-0.5D0)*PEINT
            PEQV(J1)=EXP(QV(J1)-(THISV-VZERO)/TEMPTRAJ(MYNODE)-ZT)
            IF (PEQV(J1).GT.DUMMY) THEN
               NDUMMY=J1
               DUMMY=PEQV(J1)
            ENDIF
            NORM1=NORM1+PEQV(J1)
            IF (DEBUG.AND.(PEQV(J1).GT.1.0D-10)) THEN
               WRITE(MYUNIT,'(A,I6,A,G20.10)') 'bspt> Occupation probability for bin ',J1,' is ',PEQV(J1)
            ENDIF
         ENDDO
         WRITE(MYUNIT,'(A,G20.10)') 'bspt> Check sum=',NORM1
         WRITE(MYUNIT,'(A,I6,A,G20.10)') 'bspt> Most probable PE bin is ',NDUMMY,' probability=',EXP(DUMMY)
!
! Just for fun, work out the probability of each minimum being associated
! with the most probable bin.
!
         THISV=PTEMIN+(NDUMMY-0.5D0)*PEINT
         NORM1=0.0D0
         DO J2=1,NRESMIN
            IF (THISV.GT.EMIN(J2)) THEN
               DUMMY=EXP(-FVIBMIN(J2)/2.0D0-QV(NDUMMY)-XDUMMY
     &                   +(KAPPA/2.0D0-1.0D0)*LOG((THISV-EMIN(J2))))/(1.0D0*HORDERMIN(J2))
               NORM1=NORM1+DUMMY
               WRITE(MYUNIT,'(A,I6,A,G20.10)') 'bspt> Minimum ',J2,' probability for most likely PE bin ',
     &                                     DUMMY
            ENDIF
         ENDDO
         WRITE(MYUNIT,'(A,G20.10)') 'bspt> Check sum=',NORM1
      ENDIF
!
! End of reservoir minima setup if required.
!

!
! ss2029> Open dumpenergy file for each replica 
!
      IF ( PTMCDUMPENERT ) THEN 
          WRITE (ISTR, '(I2,A1)') MYNODE+1
          ISTR=TRIM(ADJUSTL(ISTR)) // '/dumpenergy'
          WRITE(FILENAME_ENER, *) ISTR 
          ! print *,'MYNODE = ', MYNODE+1, ' file name = ', FILENAME_ENER 
          ! open file 
          FILENAME_ENER_LUNIT=GETUNIT()
          OPEN(UNIT=FILENAME_ENER_LUNIT,FILE=FILENAME_ENER, STATUS="unknown", form="formatted")
          WRITE (MYUNIT,'(A)') 'bspt> Instantaneous potential energies file = '//TRIM(ADJUSTL(FILENAME_ENER))
          WRITE (MYUNIT,'(A,I10)') 'bspt> Instantaneous potential energy output frequency = ', PTMCDUMPENERFRQ 
      ENDIF 

! For restart we need to get the current configuration, its pe, the pe of the minimum it quenched to,
! if applicable, the number of steps already done, the maximum step size, and the Visits and Visits2
! histograms. If we dump using BSPTDUMPFRQ then we can restore from the last such file. We can work
! out what the last dump was once we know how many steps have been done!
!
      IF (BSPTRESTART) THEN
         WRITE (ISTR, '(I10)') MYNODE+1
         FILENAME12=TRIM(ADJUSTL(ISTR)) // "/bsptrestart"
         LUNIT=GETUNIT()
         OPEN(UNIT=LUNIT,FILE=FILENAME12, STATUS="old", form="formatted")
         READ(LUNIT,*) PREVSTEPS,VOLD,VMINOLD,STEP(MYNODE+1),
     &                       NACCEPTPT(MYNODE),NEACCEPT,NTOT,NOUTQBIN,NOUTPEBIN,NQ(MYNODE+1)
         WRITE (MYUNIT,'(A,F20.1)') 'bspt> Number of previous steps=     ',PREVSTEPS
         WRITE (MYUNIT,'(A,2F20.10)') 'bspt> Quench and instantaneous PE=',VMINOLD,VOLD
         WRITE (MYUNIT,'(A,F20.10)') 'bspt> Step size=',STEP(MYNODE+1)
         WRITE (MYUNIT,'(A,F15.1,2I10)') 'bspt> Accepted MC steps, PT steps and total PT steps=',NACCEPTPT(MYNODE),NEACCEPT,NTOT
         WRITE (MYUNIT,'(A,3I10)') 'bspt> Quenches and instantaneous energies outside range=',NOUTQBIN,NOUTPEBIN
         WRITE (MYUNIT,'(A,I10)') 'bspt> Total quenches=',NQ(MYNODE+1)
         DO J1=1,NATOMS
            J2=3*(J1-1)
            READ(LUNIT,*) COORDS(J2+1,MYNODE+1), COORDS(J2+2,MYNODE+1), COORDS(J2+3,MYNODE+1)
         ENDDO
         CLOSE(LUNIT)
         FILENAME101=TRIM(ADJUSTL(ISTR)) // "/Visits.his"
         FILENAMEDUMMY=TRIM(ADJUSTL(FILENAME101))
         IF (BSPTDUMPFRQ.GT.0) THEN
            DUMMY=INT(PREVSTEPS/(1.0D0*BSPTDUMPFRQ))*1.0D0
!
!  Miscompiles unless we split up the calculation of DUMMY !!!
!
!           WRITE(MYUNIT,*) 'bspt> PREVSTEPS,BSPTDUMPFRQ,DUMMY=',PREVSTEPS,BSPTDUMPFRQ,DUMMY
!           WRITE(MYUNIT,*) 'bspt> INT,arg=',INT(PREVSTEPS/(1.0D0*BSPTDUMPFRQ)),PREVSTEPS/(1.0D0*BSPTDUMPFRQ)
            DUMMY=DUMMY*BSPTDUMPFRQ
!           WRITE(MYUNIT,*) 'bspt> DUMMY=',DUMMY
            CALL FLUSH(MYUNIT)
            WRITE (SDUMMY, '(F15.1)') DUMMY
            FILENAME101=TRIM(ADJUSTL(FILENAME101)) // '.' // TRIM(ADJUSTL(SDUMMY))
!
!js850> if file #/Visits.his.#####.0 doesn't exist, then check if
!          file #/Visits.his  exists and use that instead.  This is
!          a way to change BSPTDUMPFRQ after a restart
!
            INQUIRE(FILE=TRIM(ADJUSTL(FILENAME101)), EXIST=FILETEST)
            IF ( .NOT. FILETEST ) THEN
               INQUIRE(FILE=FILENAMEDUMMY, EXIST=FILETEST)
               IF ( FILETEST ) FILENAME101=FILENAMEDUMMY
            ENDIF
         ELSE
            FILENAME101=TRIM(ADJUSTL(FILENAME101)) ! this should be the final and only Visits file
         ENDIF
         IF (PREVSTEPS.GT.NEQUIL) THEN
            WRITE(MYUNIT,'(A,A)') 'bspt> Reading restart information from ',TRIM(ADJUSTL(FILENAME101))
            CALL FLUSH(MYUNIT)
            LUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME101, STATUS="unknown", form="formatted")
            READ(LUNIT, '(G20.10)') DUMMY
            READ(LUNIT, '(A)') SDUMMY
            DO K=1, NENRPER
               READ(LUNIT,*) DUMMY,PEVISITS(K,MYNODE)
            ENDDO
            READ(LUNIT, '(A)') SDUMMY
            DO K=1, HBINS
               WRITE(LUNIT,*) DUMMY, QVISITS(K,MYNODE)
            ENDDO
            CLOSE(LUNIT)
         ENDIF
         IF (BSPT.AND.(PREVSTEPS.GT.NEQUIL+PTSTEPS).AND.(.NOT.MINDENSITYT)) THEN
            FILENAME101=TRIM(ADJUSTL(ISTR)) // "/Visits2.his"
            WRITE(MYUNIT,'(A,A)') 'bspt> Reading restart information from ',TRIM(ADJUSTL(FILENAME101))
            LUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME101,STATUS="unknown",FORM="UNFORMATTED")
            READ(LUNIT) PEVISITS2(1:NENRPER,1:HBINS,MYNODE)
            CLOSE(LUNIT) 
         ENDIF
         CONVERGED=1
         IF (CANDIDATELISTT) THEN
            WRITE(FILENAME101,'(I3)') MYNODE+1
            FILENAME101=TRIM(ADJUSTL(FILENAME101)) // '/configurations'
            TEMPUNIT=GETUNIT()
            OPEN(UNIT=TEMPUNIT,FILE=FILENAME101,STATUS='UNKNOWN')
            DO K=1,HBINS
               READ(TEMPUNIT,*) NDUMMY,CANDIDATENUM(K),CANDIDATEPE(1:NCANDIDATES,K),CANDIDATET(1:NCANDIDATES,K)
               IF (CANDIDATENUM(K).EQ.0) CYCLE
               READ(TEMPUNIT,'(3G20.10)') CANDIDATECRD(1:3*NATOMS,1:NCANDIDATES,K)
            ENDDO
            CLOSE(TEMPUNIT)
            WRITE(FILENAME101,'(I3)') 'bspt> Candidate configuration data read from file ' // FILENAME101
         ENDIF
      ELSE
!
! This is the block executed if we are not restarting.
!
12       CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
         VOLD=POTEL
         WRITE(MYUNIT,'(2(A,G20.10))') 'bspt> Initial configuration energy             = ',VOLD
!        WRITE(MYUNIT,'(2(A,G20.10))') 'bspt> NOT QUENCHING initial config'
         CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
         WRITE(MYUNIT,'(A,G20.10)')    'bspt> Initial configuration quenched to energy = ',POTEL
!
!  If we start with an invalid configuration we may never recover!
!
         IF (.NOT.(CHRMMT.OR.MODEL1T.OR.PERIODIC)) THEN
             IF (PERCOLATET) THEN
               CALL PERC(COORDS(1:3*NATOMS,MYNODE+1),NATOMS,PERCCUT,PERCT,DEBUG,MYUNIT,RIGID)
               IF (.NOT.PERCT) THEN
                  WRITE(MYUNIT,'(A,I6,A)') 'bspt> ERROR *** Initial coordinates do not define a percolating system'
                  STOP
               ENDIF
            ELSE
               DO K=1,NATOMS
                  DIST=COORDS(3*(K-1)+1,MYNODE+1)**2+COORDS(3*(K-1)+2,MYNODE+1)**2+COORDS(3*(K-1)+3,MYNODE+1)**2
                  IF (DIST.GT.RADIUS) THEN
                     IF (MOD(IMCSTEP-1.0D0,1.0D0*PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,I6,A)') 'bspt> Atom ',K,
     &                       ' outside container, reseed and try again'
                     SR3=DSQRT(3.0D0)
                     DO J1=1,NATOMS
                        RANDOM=(DPRAND()-0.5D0)*2.0D0
                        COORDS(3*(K-1)+1,MYNODE+1)=RANDOM*DSQRT(RADIUS)/SR3
                        RANDOM=(DPRAND()-0.5D0)*2.0D0
                        COORDS(3*(K-1)+2,MYNODE+1)=RANDOM*DSQRT(RADIUS)/SR3
                        RANDOM=(DPRAND()-0.5D0)*2.0D0
                        COORDS(3*(K-1)+3,MYNODE+1)=RANDOM*DSQRT(RADIUS)/SR3
                     ENDDO
                     GOTO 12
                  ENDIF
               ENDDO 
            ENDIF
         ENDIF
      ENDIF

      LBFGS_ITERATIONS=0
      LBFGS_ITERATIONSO=0 ! so that we don't use quench DoS statistics from arbitrary high energy
      !VOLD=POTEL  !js850> POTEL is not defined yet for bsptrestart
      VNEW=VOLD
      DO J1=1,NATOMS
         X(J1)=COORDS(3*(J1-1)+1,MYNODE+1)
         Y(J1)=COORDS(3*(J1-1)+2,MYNODE+1)
         Z(J1)=COORDS(3*(J1-1)+3,MYNODE+1)
      ENDDO
      DO J1=1,NATOMS
         Q(1,J1)=X(J1)
         Q(2,J1)=Y(J1)
         Q(3,J1)=Z(J1)
      ENDDO

      IF (PERIODIC) THEN
         CALL QORDER_BLJ(Q,Q4,Q6)
      ELSE IF (CHRMMT) THEN
           IF (ODIHET) CALL CHCALCDIHE(DIHEORDERPARAM,COORDS(1:3*NATOMS,MYNODE+1))
           IF (OSASAT) CALL ORDER_SASA(SASAORDERPARAM,RPRO,COORDS(1:3*NATOMS:3,MYNODE+1),
     &             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1))
           IF (ORGYT) CALL CHCALCRGYR(RGYR,COORDS(1:3*NATOMS:3,MYNODE+1),
     &             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),.FALSE.) 
           IF (OEINTT) CALL CHCALCEINT(EINT,COORDS(1:3*NATOMS:3,MYNODE+1),
     &             COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),POTEL)
      ELSE
         CALL QORDER_LJ(Q,Q4,Q6)
      ENDIF

      WRITE(MYUNIT, '(A,2G20.10)') 'bspt> Temperature range             = ', TEMPTRAJ(0), TEMPTRAJ(NPAR-1)
      WRITE(MYUNIT, '(A,G20.10)')  'bspt> This temperature trajectory   = ', TEMPTRAJ(MYNODE)
      IF (.NOT.BSPTRESTART) VMINOLD=VOLD
      IF ((.NOT.BSPTRESTART).AND.(NEQUIL+PTSTEPS.GT.0)) VMINOLD=0.0D0 
      IF (RESERVOIRT) WRITE (MYUNIT,'(A,I6,A)') 'bspt> Lowest ',USERES+1,' replicas will use reservoir minima'
      WRITE (MYUNIT,'(A,F20.1)')   'bspt> Number of equilibration steps = ',NEQUIL
      WRITE (MYUNIT,'(A,F20.1)')   'bspt> Number of PT steps            = ',PTSTEPS
      WRITE (MYUNIT,'(A,F20.1)')   'bspt> Number of BSPT steps          = ',NQUENCH
      WRITE (MYUNIT,'(A,G20.10)')   'bspt> Replica Exchange Interval    = ',EXCHINT 
      WRITE (MYUNIT,'(A,G20.10)')   'bspt> Replica Exchange Prob        = ',EXCHPROB

      IF (MINDENSITYT) WRITE (MYUNIT,'(A,F20.1)') 'bspt> Accept/reject based on quench energy'
      IF (PERIODIC) WRITE(MYUNIT, '(A, 2G20.10)') 'bspt> Starting Q4, Q6=', Q4, Q6
      IF (CHRMMT) THEN
        IF (OSASAT)  WRITE(MYUNIT, '(A, 2G20.10)') 'bspt> Starting Met-enk order params=', 
     &                                         DIHEORDERPARAM, SASAORDERPARAM 
        IF (ORGYT)  WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting Rgyr order params=', 
     &                                          RGYR 
        IF (OEINTT) WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting Eint order params=',
     &                                          EINT
      ENDIF
!
! Initialisation complete
!
!   ss2029> implementing system time seed as done in mc.F  
!
      IF (RANSEEDT) THEN
        CONTINUE
      ELSE IF (RANDOMSEEDT) THEN
        CALL DATE_AND_TIME(datechar,timechar,zonechar,values)
        ITIME= values(6)*60 +  values(7)
        CALL SDPRND(ITIME)
        CALL SDPRND_UNIVERSAL(ITIME+NPAR)
        WRITE(MYUNIT, '(A)') 'bspt> Using system time to seed random number generator' 
        WRITE(MYUNIT, '(A)') 'bspt> and system time + NPAR to seed universal random number generator'
      ELSE
        WRITE(MYUNIT, '(A)') 'bspt> Using hardcoded value (=2002) as random number seed' 
        WRITE(MYUNIT, '(A)') 'bspt> and 2002 + NPAR as universal random number seed' 
        RNDSEED=2002+MYNODE
        CALL SDPRND(RNDSEED)
        CALL SDPRND_UNIVERSAL(2002+NPAR)
      ENDIF
      RANDOM=DPRAND()
      WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting local random number     = ', RANDOM
      RANDOM=DPRAND_UNIVERSAL()
      WRITE(MYUNIT, '(A, G20.10)') 'bspt> Starting universal random number = ', RANDOM


      IF (FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1)) THEN
         WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> Starting stepsize            = ', STEP(MYNODE+1),' (fixed)'
      ELSEIF ((MYNODE.LE.USERES).AND.RESERVOIRT) THEN
         WRITE(MYUNIT, '(A)') 'bspt> Configurations will only be generated from the reservoir for exchange purposes'
      ELSE
         WRITE(MYUNIT, '(A,G20.10)') 'bspt> Starting stepsize (adjusted) = ', STEP(MYNODE+1)
      ENDIF
      CALL FLUSH(MYUNIT)

      IF (.NOT.BSPTRESTART) NTOT=0
      IF (.NOT.BSPTRESTART) NACCEPTPT(MYNODE)=0.0D0
      IF (.NOT.BSPTRESTART) QVISITS(:,MYNODE)=0.0D0
      IF (.NOT.BSPTRESTART) PEVISITS(:,MYNODE)=0.0D0
      IF (.NOT.BSPTRESTART) PEVISITS2(:,:,MYNODE)=0
      IACCEPT(MYNODE)=0
      EAV(MYNODE)=0.
      EAV2(MYNODE)=0.
!
! todo - move Q4AC, Q6AV etc behind IF(CALCQT)?
!
      Q4AV(MYNODE)=0.
      Q6AV(MYNODE)=0.
      Q4AV2(MYNODE)=0.
      Q6AV2(MYNODE)=0.
      DIHEORDERPARAM_AV(MYNODE)=0.
      SASAORDERPARAM_AV(MYNODE)=0.
      DIHEORDERPARAM_AV2(MYNODE)=0.
      SASAORDERPARAM_AV2(MYNODE)=0.
      RGYR_AV(MYNODE)=0.
      EINT_AV(MYNODE)=0.
      RGYR_AV2(MYNODE)=0.
      EINT_AV2(MYNODE)=0.
      DO J1=1,NHIST
         NHISTQ4(J1,MYNODE)=0
         NHISTQ6(J1,MYNODE)=0
      ENDDO
      DO J1=1,NHISTE
         NHISTQE(J1,MYNODE)=0
      ENDDO
      NHISTALLQ(:,:,MYNODE)=0
      NHISTGRAND(:,:,:,MYNODE)=0
      DISTANCE(:,MYNODE)=0.0D0
      DISTANCE_AV(:,MYNODE)=0.0D0
      DELTA_EAV(MYNODE)=0.0D0

      Q4MAX=0.1
      Q6MAX=0.5 ! Will have to change as is rather system specific
      DIHEORDERPARAM_MIN=0.4D0
      DIHEORDERPARAM_MAX=1.0D0
      SASAORDERPARAM_MIN=300.0D0
      SASAORDERPARAM_MAX=800.0D0
      RGYR_MIN=4.0D0
      RGYR_MAX=12.0D0
      EINT_MIN=-35.0
      EINT_MAX=10.0
      DDIHE=(DIHEORDERPARAM_MAX-DIHEORDERPARAM_MIN)/(NHIST-1)
      DSASA=(SASAORDERPARAM_MAX-SASAORDERPARAM_MIN)/(NHIST-1)
      DRGYR=(RGYR_MAX-RGYR_MIN)/(NHIST-1)
      DEINT=(EINT_MAX-EINT_MIN)/(NHIST-1)
      DQ4=Q4MAX/(NHIST-1)
      DQ6=Q6MAX/(NHIST-1)
      DHISTE=(PTEMAX-PTEMIN)/(NHISTE-1)

      ENUL=VOLD
!
! NUPDATE specifies the interval for dynamically altering the maximum step size.
! Only used if step size isn't fixed.
!
! ss2029> NUPDATE is hardcoded. read from a keyword. todo.  
!
      NUPDATE=100
      IF (.NOT.(FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1).OR.((MYNODE.LE.USERES).AND.RESERVOIRT)))  THEN 
          WRITE(MYUNIT, '(A,I6,A)') 'bspt> Step size will be adjusted every ',NUPDATE ,' MC steps'
      ENDIF

      IF (DEBUGss2029) THEN
          print *,'bspt> ss2029> MYNODE = ', MYNODE+1, ' just before the main MC loop.' 
      ENDIF

      WRITE (MYUNIT,'(A)') 'bspt> Entering main MC loop ... ' 

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Main loop over steps. We have to use double precision for the number of steps, because it
! may exceed integer capacity.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      IMCSTEP=0.0D0    ! = MC step number 
      IF (BSPTRESTART) IMCSTEP=PREVSTEPS
      MCSTEPSTART = IMCSTEP
      CALL MYCPU_TIME(TIMESTART1)
      DO 
         IMCSTEP=IMCSTEP+1.0D0
         IF (IMCSTEP.GT.NEQUIL+PTSTEPS+NQUENCH) EXIT
         RECOUNT=.FALSE.
         DO K=1, NATOMS
            XO(K)=X(K)
            YO(K)=Y(K)
            ZO(K)=Z(K)
            COORDSO(3*(K-1)+1,MYNODE+1)=XO(K)
            COORDSO(3*(K-1)+2,MYNODE+1)=YO(K)
            COORDSO(3*(K-1)+3,MYNODE+1)=ZO(K)
         ENDDO
!
! Should probably worry about centre of coordinates versus centre of mass
! for heteroatomic systems.
!
         IF (CENT) THEN
            CX=0.0D0; CY=0.0D0; CZ=0.0D0
            DO K=1,NATOMS
               CX=CX+X(K); CY=CY+Y(K); CZ=CZ+Z(K)
            ENDDO
            CX=CX/NATOMS; CY=CY/NATOMS; CZ=CZ/NATOMS
            DO K=1,NATOMS
               X(K)=X(K)-CX; Y(K)=Y(K)-CY; Z(K)=Z(K)-CZ
            ENDDO
         ENDIF  
         IF ((DEBUG.OR.CHECKMARKOVT).AND.(IMCSTEP.GT.1.0D0).AND.(.NOT.CANDIDATELISTT)  
     &        .AND.(.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT))) THEN
            CALL POTENTIAL(COORDSO(:,MYNODE+1),GRAD,OPOTEL,.FALSE.,.FALSE.)
            IF (ABS(OPOTEL-VNEW).GT.ECONV) THEN
               WRITE(MYUNIT,'(3(A,G20.10))') 'bspt> possible ERROR - energy for coordinates in COORDSO=',
     &                     OPOTEL,' but Markov energy=',VNEW,' IMCSTEP=',IMCSTEP
               STOP
            ENDIF
            IF (PERCOLATET) THEN
               CALL PERC(COORDSO(1:3*NATOMS,MYNODE+1),NATOMS,PERCCUT,PERCT,DEBUG,MYUNIT,RIGID)
               IF (.NOT.PERCT) THEN
                  IF (MOD(IMCSTEP-1.0D0,PRTFRQ*1.0D0).EQ.0.0D0) WRITE(MYUNIT,'(A)') 
     &              'bspt> Markov structure is not a percolating network'
               ENDIF
            ENDIF
         ENDIF
!
! Try moving to a candidate configuration if available.  
!
         CANDIDATEWEIGHT=1.0D0
         JUMPT=.FALSE.
!          IF (CANDIDATELISTT.AND.(IMCSTEP.GT.NEQUIL+PTSTEPS+1)) THEN
!             RANDOM=DPRAND()
!             IF (RANDOM.LE.CANDIDATEFRQ) THEN
! !                BININDEX=INT((VMINOLD-HISTMIN)/HISTINT)+1
! !                IF ((BININDEX.GT.HBINS).OR.(BININDEX.LT.1)) THEN
! !                   WRITE(MYUNIT,'(A,G20.10,A,I8))') 
! !      &              'bspt> WARNING *** quench energy ',VMINOLD,
! !      &              ' for current configuration is outside range, bin index=',BININDEX
! !                   RECOUNT=.TRUE.
! !                ELSE
! ! !                 NDUMMY=INT(DPRAND()*HBINS)+1
! !                   NDUMMY=INT(DPRAND()*(MIN(BININDEX+CANDIDATESEP,HBINS)-MAX(BININDEX-CANDIDATESEP,1)))
! !                   NDUMMY=MAX(BININDEX-CANDIDATESEP,1)+NDUMMY
! !                   IF (CANDIDATENUM(BININDEX).NE.0) THEN
! !                      CANDIDATEWEIGHT=(1.0D0*MIN(NCANDIDATES,CANDIDATENUM(NDUMMY)))
! !      &                              /(1.0D0*MIN(NCANDIDATES,CANDIDATENUM(BININDEX)))
! ! !
! ! ! The weight should probably proprtional to the total number of visits to this quench bin,
! ! ! not the number we've actually saved.
! ! !
! ! !                    CANDIDATEWEIGHT=(1.0D0*CANDIDATENUM(NDUMMY))/(1.0D0*CANDIDATENUM(BININDEX))
! !                      WRITE(MYUNIT,'(A,4I8,G20.10))') 
! !      &                    'A NDUMMY,BININDEX,CNUM(NDUMMY),CNUM(BININDEX),CANDIDATEWEIGHT=',
! !      &                       NDUMMY,BININDEX,CANDIDATENUM(NDUMMY),CANDIDATENUM(BININDEX),CANDIDATEWEIGHT
! !                      IF (CANDIDATEWEIGHT.GT.0.0D0) THEN
! !                         RANDOM=DPRAND()
! !                         N1=MIN(CANDIDATENUM(NDUMMY),NCANDIDATES)
! !                         NDUMMY2=INT(RANDOM*N1)+1
! !                         CANDIDATEWEIGHT=
! !      &   CANDIDATEWEIGHT*EXP(-CANDIDATEPE(NDUMMY2,NDUMMY)/CANDIDATET(NDUMMY2,NDUMMY)+VOLD*BETA(MYNODE))
! !                         WRITE(MYUNIT,'(A,2I8,G20.10))') 
! !      &                    'B CANDIDATENUM(NDUMMY),CANDIDATENUM(BININDEX),CANDIDATEWEIGHT=',
! !      &                     CANDIDATENUM(NDUMMY),CANDIDATENUM(BININDEX),CANDIDATEWEIGHT
! !                            WRITE(MYUNIT,'(2(A,I8),2(A,G20.10))') 
! !      &                      'bspt> Attempt move from candidate configuration ',NDUMMY2,' in quench bin ',
! !      &                      NDUMMY,' PE ',CANDIDATEPE(NDUMMY2,NDUMMY),
! !      &                      ' temperature=',CANDIDATET(NDUMMY2,NDUMMY)
! !                         CALL FLUSH(MYUNIT)
! !                         DO K=1, NATOMS
! !                            X(K)=CANDIDATECRD(3*(K-1)+1,NDUMMY2,NDUMMY)
! !                            Y(K)=CANDIDATECRD(3*(K-1)+2,NDUMMY2,NDUMMY)
! !                            Z(K)=CANDIDATECRD(3*(K-1)+3,NDUMMY2,NDUMMY)
! !                         ENDDO
! !                         IF (DEBUG.OR.CHECKMARKOVT) THEN
! !                            LCOORDS(1:3*NATOMS)=CANDIDATECRD(1:3*NATOMS,NDUMMY2,NDUMMY)
! !                            CALL POTENTIAL(LCOORDS,GRAD,DUMMY,.TRUE.,.FALSE.)
! !                            IF (ABS(DUMMY-CANDIDATEPE(NDUMMY2,NDUMMY)).GT.ECONV) THEN
! !                               WRITE(MYUNIT,'(A,2G20.10))') 
! !      &                            'bspt> ERROR *** PE for candidate structure and saved PE are ',
! !      &                       DUMMY,CANDIDATEPE(NDUMMY2,NDUMMY)
! !                               WRITE(MYUNIT,'(A,10G20.10))') 'CANDIDATEPE(:,NDUMMY)=',
! !      &                                                       CANDIDATEPE(1:NDUMMY2,NDUMMY)
! !                               DO K=1,NDUMMY2
! !                                  WRITE(MYUNIT,'(A,I8)') 'CANDIDATECRD ',K
! !                                  WRITE(MYUNIT,'(3G20.10))') CANDIDATECRD(1:3*NATOMS,K,NDUMMY)
! !                               ENDDO
! !                               STOP
! !                            ENDIF
! !                         ENDIF
! !                      ELSE
! !                         CANDIDATEWEIGHT=1.0D0
! !                      ENDIF
! !                   ELSE
! !                      WRITE(MYUNIT,'(A,I8)')
! !      &                  'bspt> WARNING *** number of candidiates for current bin=',CANDIDATENUM(BININDEX)
! !                   ENDIF
! !                ENDIF
!                NDUMMY=INT(DPRAND()*PTCANDN)+1
! !              CANDIDATEWEIGHT=EXP(-(PTCANDE(NDUMMY)-VOLD)*BETA(MYNODE))
! !
! ! For jump attempts without perturbations.
! !
!                CANDIDATEWEIGHT=1.0D0
!                WRITE(MYUNIT,'(A,I8,A,G20.10)') 'bspt> Attempt jump move from configuration ',NDUMMY,' PE ',PTCANDE(NDUMMY)
!                CALL POTENTIAL(PTCAND(NDUMMY,1:3*NATOMS),GRAD,DUMMY,.TRUE.,.FALSE.)
!                WRITE(MYUNIT,'(A,G20.10)') 'bspt> Energy of saved configuration=',DUMMY
!                IF (ABS(DUMMY-PTCANDE(NDUMMY)).GT.ECONV) THEN
!                   WRITE(MYUNIT,'(A,2G20.10))') 'bspt> ERROR *** PE for saved structure and saved PE are ',DUMMY,PTCANDE(NDUMMY)
!                   STOP
!                ENDIF
!                JUMPT=.TRUE.
!                CALL FLUSH(MYUNIT)
!                DO K=1, NATOMS
!                   X(K)=PTCAND(NDUMMY,3*(K-1)+1)
!                   Y(K)=PTCAND(NDUMMY,3*(K-1)+2)
!                   Z(K)=PTCAND(NDUMMY,3*(K-1)+3)
!                ENDDO
!             ENDIF
!          ENDIF
!        CANDIDATEWEIGHT=1.0D0  ! DJW for testing
!
! If a move is rejected, the result for the current configuration
! should be recounted. This allows for the unsymmetrical forward
! and backward move probabilities for an atom near the surface of
! the constraining sphere.
!             
         IF (CHRMMT) THEN
            ! Random cartesian move for CHARMM
            DO K=1,NATOMS
               RANDOM=DPRAND()
               X(K) = X(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)
               RANDOM=DPRAND()
               Y(K) = Y(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)
               RANDOM=DPRAND()
               Z(K) = Z(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)
            ENDDO
!
! Try jumps with no perturbations.
!
         ELSEIF (.NOT.JUMPT) THEN
            IF ( BINARY_EXAB .AND. (MOD(IMCSTEP-1.0D0,BINARY_EXAB_FRQ*1.0D0).EQ.0.0D0) ) THEN
               !js850> try to exchange a type A and type B particle as the MC step
               EXAB_COUNT = EXAB_COUNT + 1
               !choose an A and a B particle
               IF ( FREEZE ) THEN
                 !get a mobile type B particle
                 !NMOBILETYPEB = NTYPEB - NFREEZETYPEB = (NATOMS - NTYPEA) - (NFREEZE - NFREEZETYPEA)
                 J3 = (NATOMS - NTYPEA) - (NFREEZE - NFREEZETYPEA) !NMOBILETYPEB
           !      write(*,*) NATOMS , NTYPEA,  NFREEZE , NFREEZETYPEA
                 !J4=       *( NMOBILETYPEB ) +1 + NFREEZE + (NMOBILETYPEA)
                 RANDOM=DPRAND()
                 J4 = RANDOM*( J3           ) +1 + NFREEZE + (NTYPEA-NFREEZETYPEA)
                 J2 = FROZENLIST(J4)
                 !get a mobile type A particle
                 !NMOBILETYPEA = NTYPEA - NFREEZETYPEA
                 !J1=       *( NMOBILETYPEA ) +1 + NFREEZE
                 RANDOM=DPRAND()
                 J4 = RANDOM*( NTYPEA-NFREEZETYPEA ) + 1 + NFREEZE
                 J1 = FROZENLIST(J4)
               ELSE
                 RANDOM=DPRAND()
                 J1 = RANDOM*NTYPEA + 1
                 RANDOM=DPRAND()
                 J2 = RANDOM*(NATOMS-NTYPEA) + 1 + NTYPEA
               ENDIF
               !WRITE(MYUNIT,*) "trying exchange ", J1, J2, IMCSTEP
               !IF ( FROZEN(J1) .OR. FROZEN(J2) .OR. J1 .GT. NTYPEA .OR. J2 .LE.  NTYPEA ) THEN
                 !WRITE(*,*) "problem with binary_exab", j1, j2, frozen(j1), frozen(j2), nfreeze
                 !CALL EXIT()
               !endif
               !exchange the xyz coordinates of J1 and J2
               DUMMY = X(J1)
               X(J1) = X(J2)
               X(J2) = DUMMY
               DUMMY = Y(J1)
               Y(J1) = Y(J2)
               Y(J2) = DUMMY
               DUMMY = Z(J1)
               Z(J1) = Z(J2)
               Z(J2) = DUMMY
            ELSEIF (.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT)) THEN
               ! Random cartesian move if 
               !       CHRMMT=RESERVOIRT=JUMPT=FALSE & MYNODE>=USERES
               IF (DEBUGss2029) THEN  
                  WRITE(MYUNIT, '(A,G20.10)') "bspt> Random cartesian move; MCSTEP = ", IMCSTEP 
               ENDIF 

               DO K=1,NATOMS
                  RANDOM=DPRAND()
                  X(K) = X(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
                  RANDOM=DPRAND()
                  Y(K) = Y(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
                  RANDOM=DPRAND()
                  Z(K) = Z(K) + 2.0D0*RANDOM*STEP(MYNODE+1)-STEP(MYNODE+1)  
               ENDDO
            ELSE
!
! This is the case where we select a potential energy bin for node 0 from a reservoir.
!
               RANDOM=DPRAND()
               DUMMY=0.0D0
               NCHOSEN=-1
               DO K=1,NENRPER
                  DUMMY=DUMMY+PEQV(K)
                  IF (RANDOM.LE.DUMMY) THEN
                     VNEW=PTEMIN+(K-0.5D0)*PEINT
                     NCHOSEN=K
                     EXIT
                  ENDIF 
               ENDDO
               IF (NCHOSEN.EQ.-1) THEN
                  WRITE(MYUNIT,'(A)') 'bspt> ERROR *** PE bin not selected'
                  STOP
               ENDIF
               IF (MOD(IMCSTEP-1.0D0*1,1.0D0*PRTFRQ).EQ.1.0D0*0) WRITE(MYUNIT,'(A,I6,A,G20.10)') 'bspt> Selected bin ',
     &                                                                                      NCHOSEN,' with PE=   ',VNEW
            ENDIF
         ENDIF   ! closes IF (CHRMMT) THEN 

         OUTSIDE=.FALSE.

         IF (.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT)) THEN
            ! reservoir stuff 
            IF (.NOT.(CHRMMT.OR.MODEL1T.OR.PERCOLATET.OR.PERIODIC)) THEN
               cloop: DO K=1,NATOMS
                  DIST=X(K)**2+Y(K)**2+Z(K)**2
                  IF (DIST.GT.RADIUS) THEN
                     IF (MOD(IMCSTEP-1.0D0,PRTFRQ*1.0D0).EQ.0.0D0) WRITE(MYUNIT,'(A,I6,A)') 'bspt> Perturbed atom ',K,
     &                    ' outside container, recount previous configuration results'
                     XOUT=XOUT+1.0D0
                     OUTSIDE=.TRUE.
                     RECOUNT=.TRUE. ! The right way to deal with rejected steps!
                     EXIT cloop
                  ENDIF
               ENDDO cloop
            ENDIF

            IF (FREEZE) THEN
               DO J1=1,NFREEZE
                  J2=FROZENLIST(J1)
                  X(J2)=XO(J2)
                  Y(J2)=YO(J2)
                  Z(J2)=ZO(J2)
               ENDDO
            ENDIF

            ! copying post-move coordinates 
            DO K=1,NATOMS
               COORDS(3*(K-1)+1,MYNODE+1)=X(K)
               COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
               COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
            ENDDO

            IF (PERCOLATET) THEN
               CALL PERC(COORDS(1:3*NATOMS,MYNODE+1),NATOMS,PERCCUT,PERCT,DEBUG,MYUNIT,RIGID)
               IF (.NOT.PERCT) THEN
                  IF (MOD(IMCSTEP-1.0D0,PRTFRQ*1.0D0).EQ.0.0D0) WRITE(MYUNIT,'(A,I6,A)') 
     &                 'bspt> After step system is not a percolating network, recount previous configuration results'
                  XOUT=XOUT+1.0D0
                  OUTSIDE=.TRUE.
                  RECOUNT=.TRUE. ! The right way to deal with rejected steps!
               ENDIF
            ENDIF
!
! js850> Check to see if RESTRICTREGION constraints have been violated - if they have, reject the step
!
            IF ( RESTRICTREGION ) THEN
              !RESTRICTREGIONTEST=.FALSE.
              DO J1=1,NATOMS
                IF ( .NOT. FROZEN(J1) .AND. .NOT. HARMONICFLIST(J1) 
     &       .AND. .NOT. DONTMOVE(J1) ) THEN
                  RRX = ( X(J1)-RESTRICTREGIONX0 )
                  RRY = ( Y(J1)-RESTRICTREGIONY0 )
                  RRZ = ( Z(J1)-RESTRICTREGIONZ0 )
                  RRX = RRX - ANINT(RRX/BOXLX)*BOXLX
                  RRY = RRY - ANINT(RRY/BOXLY)*BOXLY
                  IF ( RESTRICTCYL ) THEN
                    RRZ = 0
                    RRR = DSQRT(RRX**2+RRY**2 )
                  ELSE
                    RRZ = RRZ - ANINT(RRZ/BOXLZ)*BOXLZ
                    RRR = DSQRT(RRX**2+RRY**2+RRZ**2 )
                  ENDIF
                  IF ( RRR > RESTRICTREGIONRADIUS ) THEN
                    RECOUNT=.TRUE.
                    WRITE(MYUNIT, *) 'bspt> restrictregion> rejecting step ', IMCSTEP
                    !GOODSTRUCTURE=.FALSE.
                    !RESTRICTREGIONTEST=.TRUE.
                    EXIT !exit loop
                  ENDIF
                ENDIF
              ENDDO
            ENDIF
         ENDIF ! closes IF (.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT))
!
! At this point all we have done is take a step, energies have not been computed yet and 
! also Metropolis check has not been done. 
!
! The perturbed coordinates are in both COORDS and X, Y, Z. 
! The old coordinates are in XO, YO, ZO. 
!
! For node 0 and reservoir, we have instead chosen a PE bin.
!
! New and old quench energies will be in        VMINNEW VMINOLD
! New and old inst   energies will be in        VNEW    VOLD
!
         IF (DEBUGss2029) THEN 
             IF (MYNODE.EQ.0) print *,'bspt> ss2029: one MC step = ', IMCSTEP,' RECOUNT = ', RECOUNT 
         ENDIF
!
! ss2029> Compute energy of perturbed coordinates and apply Metropolis check.   
!         If the step is to be rejected, RECOUNT is set to TRUE 
!
         IF (RECOUNT) THEN
            VNEW=0.0D0
         ELSEIF (.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT)) THEN
            CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD,POTEL,.TRUE.,.FALSE.)
            VNEW=POTEL
            IF (.NOT.MINDENSITYT) THEN
            ! ss2029> this is where Metropolis check on instantaneous energy is done. 
               WCOMP=(VNEW-VOLD)*BETA(MYNODE) ! use difference in instantaneous energies
               W=MIN(1.0D0,EXP(-WCOMP))
               W=MIN(1.0D0,CANDIDATEWEIGHT*EXP(-WCOMP))
               RANDOM=DPRAND()
               IF (RANDOM.GT.W) RECOUNT=.TRUE. ! RECOUNT is initialised to .FALSE. at the top of the loop
               IF (JUMPT)  WRITE(MYUNIT, '(A,4G20.10,L5)') 'bspt> VOLD,VNEW,W,RANDOM,RECOUNT=',VOLD,VNEW,W,RANDOM,RECOUNT
            ENDIF
         ENDIF

! histogram bounds check on VNEW  
         IBININDEX=INT((VNEW-PTEMIN)/PEINT)+1
         IF (BSPT.AND.((IBININDEX.GT.NENRPER).OR.(IBININDEX.LT.1))) THEN
            IF (.NOT.MINDENSITYT) RECOUNT=.TRUE.
!           RECOUNT=.TRUE.
            IF (.NOT.OUTSIDE) NOUTPEBIN=NOUTPEBIN+1
         ENDIF
!
! Quenching part if required.
! COORDSO saves the perturbed coordinates before the quench in order to calculate
! a quench distance. Should no longer be needed. COORDS are used as scratch for quenches.
!
         COORDSO(:,MYNODE+1)=COORDS(:,MYNODE+1) 
         IF ((RECOUNT.AND.BSPT).OR.(IMCSTEP.LE.NEQUIL+PTSTEPS)) THEN
            VMINNEW=0.0D0
            LBFGS_ITERATIONS=0
         ENDIF

         ! ss2029> advanced BSPT to outermost IF
         IF (BSPT.AND.MINDENSITYT.OR.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN
            
            IF ((.NOT.RECOUNT)) THEN 
               IF (MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.1.0D0*0) THEN 
                  IF ((MYNODE.LE.USERES).AND.RESERVOIRT) THEN
                     WRITE(MYUNIT,'(A)') 'bspt> Reservoir not coded yet for BSPT - quit'
                     VMINNEW=0.0D0
                     LBFGS_ITERATIONS=0
                     EVAPREJECT=.FALSE.
                     CONVERGED=1
                     POTEL=HUGE(1.0D0)
                     STOP
                  ELSE
!                    WRITE(MYUNIT, '(A)') 'bspt> calling quench'
                     IF (CHRMMT.AND.ACESOLV) NCHENCALLS=ACEUPSTEP-1
                     CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
                     IF (CONVERGED.NE.1) WRITE(MYUNIT, '(A)') 'bspt> WARNING - quench did not converge' 
                     VMINNEW=POTEL
                     NQ(MYNODE+1)=NQ(MYNODE+1)+1
                     MINCOORDS(:,MYNODE+1)=COORDS(:,MYNODE+1) ! MINCOORDS contains quench coords
                  ENDIF
               ELSE
                  VMINNEW=0.0D0
                  LBFGS_ITERATIONS=0
                  EVAPREJECT=.FALSE.
                  CONVERGED=1
                  POTEL=HUGE(1.0D0)
               ENDIF
            ELSEIF (RECOUNT.AND.(VMINOLD.EQ.0.0D0).AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.0.0D0)) THEN
            !
            ! We might not have quenched at the step to be recounted, so we have to do so here.
            !
               IF (DEBUG) WRITE(MYUNIT, '(A,G20.10,A)') 'bspt> recounting step for previous configuration with VMINOLD=',
     &                                     VMINOLD,' need to call quench'
               DO K=1,NATOMS
                 COORDS(3*(K-1)+1,MYNODE+1)=XO(K)
                 COORDS(3*(K-1)+2,MYNODE+1)=YO(K)
                 COORDS(3*(K-1)+3,MYNODE+1)=ZO(K)
               ENDDO
!              WRITE(MYUNIT, '(A)') 'bspt> calling quench for recount'
               IF(CHRMMT.AND.ACESOLV) NCHENCALLS=ACEUPSTEP-1
               CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,COORDS(:,MYNODE+1),DOSSTATS)
               NQ(MYNODE+1)=NQ(MYNODE+1)+1
               MINCOORDS(:,MYNODE+1)=COORDS(:,MYNODE+1) ! MINCOORDS contains quench coords
               VMINOLD=POTEL
               IF (CONVERGED.NE.1) WRITE(MYUNIT, '(A)') 'bspt> WARNING - quench did not converge' 
               IF (DEBUG) WRITE(MYUNIT, '(A,G20.10)') 'bspt> VMINOLD set to ',VMINOLD
            ENDIF
         ENDIF ! closes IF (MINDENSITYT.OR.(IMCSTEP.GT.NEQUIL+PTSTEPS))
!
! If either the PE (VNEW) or quench energy (VMINNEW) is out of range of the histogram
! then we may reject the step and recount the previous one.
!
! BININDEX for quench bin
! IBININDEX for instantaneous bin
!
         IF (BSPT.AND.((IMCSTEP.GT.NEQUIL+PTSTEPS).OR.(MINDENSITYT)).AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.0.0D0)) THEN
            BININDEX=INT((VMINNEW-HISTMIN)/HISTINT)+1
            IF ((BININDEX.GT.HBINS).OR.(BININDEX.LT.1)) THEN
               RECOUNT=.TRUE.
               IF (.NOT.OUTSIDE) NOUTQBIN=NOUTQBIN+1
            ENDIF
         ENDIF
         IF (MINDENSITYT) THEN
            WCOMP=(VMINNEW-VMINOLD)*BETA(MYNODE) ! use difference in quench energies for MINDENSITYT
            W=MIN(1.0D0,EXP(-WCOMP))
            W=MIN(1.0D0,CANDIDATEWEIGHT*EXP(-WCOMP))
            RANDOM=DPRAND()
            IF (RANDOM.GT.W) RECOUNT=.TRUE. 
         ENDIF

         IF (DEBUGss2029) THEN
             IF (MYNODE.EQ.0) print *,'bspt> ss2029: three MC step = ', IMCSTEP,' RECOUNT = ', RECOUNT 
         ENDIF
         VMINNEWSAVE=VMINNEW
         LBFGS_ITERATIONSSAVE=LBFGS_ITERATIONS
         VNEWSAVE=VNEW        ! this value is saved so it can be printed if the step is rejected

         IF ((CONVERGED.NE.1).OR.EVAPREJECT) RECOUNT=.TRUE. ! reject and recount
!
! ss2029> finally! this is where the move is accepted/rejected 
!
         IF (RECOUNT) THEN ! reject move
            ! 
            ! ss2029> overwriting post-move coordinates X,Y,Z why over writing post-move coordinates X,Y,Z?
            !         needed because XO, YO and ZO are initialized to X,Y,Z at the top of the loop. 
            !         Post-move coordinates are lost at this point. If needed, add another variable for post-move coords.
            !          
            DO K=1, NATOMS
               X(K)=XO(K)
               Y(K)=YO(K)
               Z(K)=ZO(K)
            ENDDO
            DO K=1,NATOMS
              COORDS(3*(K-1)+1,MYNODE+1)=X(K)
              COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
              COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
            ENDDO
            VMINNEW=VMINOLD
            VNEW=VOLD
            DOSSTATS(1:MAXIT,1:2)=DOSSTATSO(1:MAXIT,1:2)
            LBFGS_ITERATIONS=LBFGS_ITERATIONSO
            IF (.NOT.FITS) NOUT(MYNODE)=NOUT(MYNODE)+1
         ELSE ! accept move
            ! since move is accepted, no change to COORDS(..,MYNODE+1)
            NACCEPTPT(MYNODE)=NACCEPTPT(MYNODE)+1.0D0
            IACCEPT(MYNODE)=IACCEPT(MYNODE)+1
            IF (CANDIDATELISTT.AND.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN
               CANDIDATENUM(BININDEX)=CANDIDATENUM(BININDEX)+1
               NDUMMY=MOD(CANDIDATENUM(BININDEX),NCANDIDATES) ! maintain cyclic list
               IF (NDUMMY.EQ.0) NDUMMY=NCANDIDATES
               DO K=1,NATOMS
                  CANDIDATECRD(3*(K-1)+1,NDUMMY,BININDEX)=X(K)
                  CANDIDATECRD(3*(K-1)+2,NDUMMY,BININDEX)=Y(K)
                  CANDIDATECRD(3*(K-1)+3,NDUMMY,BININDEX)=Z(K)
               ENDDO
               CANDIDATEPE(NDUMMY,BININDEX)=VNEWSAVE
               CANDIDATET(NDUMMY,BININDEX)=TEMPTRAJ(MYNODE)
               WRITE(MYUNIT,'(2(A,I8))') 'bspt> Adding structure to candidate list entry ',
     &                                   NDUMMY,' for quench bin ',BININDEX
            ENDIF
            IF ( BINARY_EXAB .AND. (MOD(IMCSTEP-1.0D0,BINARY_EXAB_FRQ*1.0D0).EQ.0.0D0) ) EXAB_ACC = EXAB_ACC + 1
         ENDIF ! closes IF (RECOUNT)
!
! ss2029> Local MC move has been accepted/rejected. Stats can be collected now.
! No replica exchange  so far. 
!
         SDUMMY='ACC'
         IF (RECOUNT) SDUMMY='REJ'
         IF (MOD(IMCSTEP-1.0D0*1,1.0D0*PRTFRQ).EQ.1.0D0*0) THEN
            IF ( PTMC .AND. .NOT. BSPT ) THEN !js850> no need to print energies of minima
               WRITE(MYUNIT, '(F15.1,A,F20.10,A,F20.10,A,I6,1X,A)') 
     &         IMCSTEP,' Vn=', VNEWSAVE,' Vo=',VOLD,' iter ',
     &         LBFGS_ITERATIONSSAVE,TRIM(ADJUSTL(SDUMMY))
            ELSE
               WRITE(MYUNIT, '(F15.1,A,G16.6,A,G16.6,A,G16.6,A,G16.6,A,I6,1X,A)') 
     &         IMCSTEP,' En= ', VMINNEWSAVE, ' Eo= ',VMINOLD, ' Vn=', VNEWSAVE,' Vo=',VOLD,' iter ',
     &         LBFGS_ITERATIONSSAVE,TRIM(ADJUSTL(SDUMMY))
            ENDIF
            !write the time per step
            CALL MYCPU_TIME(TIME2)
            WRITE(MYUNIT, '(A,G20.10,F20.1)') "bspt>      time (sec) per step ", (time2-timestart1)/(IMCSTEP-mcstepstart), 
     &               IMCSTEP-mcstepstart
         ENDIF
         IF (DEBUG) THEN
!           IF (.NOT.((MYNODE.LE.USERES).AND.RESERVOIRT)) THEN
!              CALL POTENTIAL(COORDS(:,MYNODE+1),GRAD, POTEL, .TRUE., .FALSE.)
!              WRITE(MYUNIT,'(A,G20.10)') 'bspt> potential energy after acc/rej=',POTEL
!           ELSE
!              WRITE(MYUNIT,'(A,G20.10)') 'bspt> potential energy after acc/rej=',VNEW
!           ENDIF
            IF (MOD(IMCSTEP-1.0D0,1.0D0*PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,2F15.1)') 
     &         'bspt> Last exchanges to replicas above and below were at steps: ',LASTEXUP(MYNODE),LASTEXDOWN(MYNODE)
         ENDIF
         CALL FLUSH(MYUNIT)
!
!  At this point the quench and instantaneous energies for the current
!  configuration in the Markov chain are VMINNEW and VNEW.
!
!  QUENCHFRQ must be initialised to one for PTMC to avoid division by zero!
!
         IF (MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.1.0D0*0) BININDEX=INT((VMINNEW-HISTMIN)/HISTINT)+1
         IBININDEX=INT((VNEW-PTEMIN)/PEINT)+1
!
!  Must not accumulate statistics until we have equilibrated for NEQUIL steps.
!
         IF (IMCSTEP.GT.NEQUIL) THEN
            ! BSPT stuff 
            IF (BSPT.AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.0.0D0).AND.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN 
               IF (CANDIDATELISTT.AND.(MOD(IMCSTEP,1.0D0*CANDIDATEINT*1.0D0).EQ.0.0D0)) THEN
               !
               !  Update candidate structures and information on disk. Could replace by MPI?
               !
                  WRITE(FILENAME101,'(I3)') MYNODE+1 
                  FILENAME101=TRIM(ADJUSTL(FILENAME101)) // '/configurations'
                  TEMPUNIT=GETUNIT()
                  OPEN(UNIT=TEMPUNIT,FILE=FILENAME101,STATUS='UNKNOWN')
                  DO K=1,HBINS
                     IF (CANDIDATENUM(K).EQ.0) CYCLE
                     WRITE(TEMPUNIT,'(2I8,2000G20.10)') K,CANDIDATENUM(K),CANDIDATEPE(1:NCANDIDATES,K),
     &                                                CANDIDATET(1:NCANDIDATES,K)
                     WRITE(TEMPUNIT,'(3G20.10)') CANDIDATECRD(1:3*NATOMS,1:NCANDIDATES,K)
                  ENDDO
                  CLOSE(TEMPUNIT)
               ENDIF
               IF (BINSTRUCTURES.AND.(MOD(IMCSTEP, 1.0D0*SAVENTH).EQ.1.0D0*0).AND.(.NOT.RECOUNT)) THEN 
                  CALL SAVEBINSTRUCTURESMPI(POTEL,MINCOORDS(:,MYNODE+1),BININDEX,.TRUE.,MYNODE,NEWENERGY,MYUNIT)
!                 IF (NEWENERGY) THEN 
!                     MINIMANUMBER(BININDEX, MYNODE)=MINIMANUMBER(BININDEX, MYNODE)+1
!                 ENDIF
               ENDIF
            ENDIF 
            ! closes IF (BSPT.AND...) 

!           IF (BSPT.AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.0.0D0).AND.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN
!              IF ((BININDEX.GT.HBINS).OR.(BININDEX.LT.1)) GOTO 888
!           ENDIF
!           IF ((IBININDEX.GT.NENRPER).OR.(IBININDEX.LT.1)) GOTO 888

            ! Must protect histograms from out-of-bounds error if we are not recounting.
            ! 
            IF ((IBININDEX.LE.NENRPER).AND.(IBININDEX.GE.1)) THEN
            ! Don't count visits if this is the replica above a reservoir and we are within EXEQ steps of
            ! a successful exchange down.
               IF (.NOT.(RESERVOIRT.AND.(MYNODE.EQ.USERES+1).AND.(IMCSTEP.LT.LASTEXDOWN(MYNODE)+EXEQ))) THEN
                  PEVISITS(IBININDEX,MYNODE)=PEVISITS(IBININDEX,MYNODE)+1.0D0
               ENDIF
            ENDIF

            ! BSPT stuff 
            IF (BSPT.AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.0.0D0).AND.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN ! otherwise BININDEX could be out of range
               IF ((BININDEX.LE.HBINS).AND.(BININDEX.GE.1)) THEN
                  IF (.NOT.(RESERVOIRT.AND.(MYNODE.EQ.USERES+1).AND.(IMCSTEP.LT.LASTEXDOWN(MYNODE)+EXEQ))) THEN
                     QVISITS(BININDEX,MYNODE)=QVISITS(BININDEX,MYNODE)+1.0D0
                     IF ((IBININDEX.LE.NENRPER).AND.(IBININDEX.GE.1)) THEN
                        PEVISITS2(IBININDEX,BININDEX,MYNODE)=PEVISITS2(IBININDEX,BININDEX,MYNODE)+1
                     ENDIF
                  ENDIF
               ENDIF
            ENDIF


! at this point the state points are saved in the following variables (from what
! IMCSTEP can tell -- js850).  For COORDS is used as scratch space
!  ---The saved markov state unquenched:
!              X0, Y0, Z0      energy=VOLD
!  ---The saved markov state quenched: (or unquenched if PTMC)
!              ?????           energy=VMINOLD
!  ---After the step, but unquenched:
!              not saved        energy=VNEWSAVE?
!  ---After the quench:
!              MINCOORDS?       energy=VMINNEWSAVE?
!  ---The current markov state unquenched: i.e. after the step was accepted or rejected.
!              X, Y, Z          energy=VNEW
!  ---The current markov state quenched (or unquenched if PTMC): i.e. after the step was accepted or rejected.
!              ?????????        energy=VMINNEW
!

! 
! ss2029> another summary, reconciled with js850's summary above. 
!
! Just considering PTMC (no quenching), infact, this is just
! MC, PT has not been done yet. That is later around the TRYEXCHANGE call
! So just for PT, important variables are: 
!  
!     --- pre-move 
!            coord = XO,YO,ZO   energy = VOLD  
!     --- post-move and post-Metropolis  
!            coord = X, Y, Z    energy = VNEW (if accepted) 
!            coord and energy are lost if rejected  
!     --- Outcome of Metropolis and other checks 
!            RECOUNT = FALSE if accepted 
!                    = TRUE  if rejected
!     --- Markov state post Metropolis 
!            coord = COORDS      energy = VNEW              
!

!
! Should take out the distance if we aren't going to use it DJW
!
            IF (BSPT.AND.(MOD(IMCSTEP,1.0D0*QUENCHFRQ).EQ.1.0D0*0).AND.(IMCSTEP.GT.NEQUIL+PTSTEPS)) THEN
               DISTANCEOLD=CALCULATEDDISTANCE(COORDS(:,MYNODE+1), COORDSO(:,MYNODE+1))
               DISTANCE(BININDEX,MYNODE)=DISTANCE(BININDEX,MYNODE)+DISTANCEOLD
            ENDIF

!
! ss2029> write Markov energy to repNum/dumpenergy 
!
           IF ( PTMCDUMPENERT ) THEN
             IF ( (IMCSTEP.GE.NEQUIL) .AND. (MOD(IMCSTEP-1.0D0,PTMCDUMPENERFRQ*1.0D0).EQ.0.0D0) ) THEN
             ! print *, 'MCstep = ', IMCSTEP , '   Markov Ener = ', VNEW 
               WRITE(FILENAME_ENER_LUNIT,'(G20.10,A,G20.06)') IMCSTEP,'      ',  VNEW 
             ENDIF 
           ENDIF 

!
! js850> PTMCDUMPSTRUCT
!
           IF ( PTMCDUMPSTRUCT .AND. (MOD(IMCSTEP-1.0D0,PTMCDS_FRQ*1.0D0).EQ.0.0D0) ) THEN

             ! create dumpstruct.repname 
             WRITE(FILENAME106,*) 'dumpstruct.'
             WRITE(SDUMMY,'(I3)') MYNODE+1 
             FILENAME106=TRIM(ADJUSTL(FILENAME106)) // TRIM(ADJUSTL(SDUMMY))
             
             !ss2029> create replicaNumber/dumpstruct instead of dumpstruct.replicaNumber 
             !
             !WRITE(SDUMMY,'(I3)') MYNODE+1 
             !FILENAME106=TRIM(ADJUSTL(SDUMMY)) // '/dumpstruct' 

             !
             !  ss2029> dumpstruct.# files are being opened and closed within this main loop. Might be better to 
             !       open and close only once outside the loop as done for
             !       FILENAME_ENER above. todo 
             !
             TEMPUNIT=GETUNIT()
             IF ( PTMCDS_NEW .AND. BSPTRESTART ) THEN 
               OPEN(UNIT=TEMPUNIT,FILE=FILENAME106, STATUS="unknown", form="formatted")
               PTMCDS_NEW = .FALSE.
             ELSE
               OPEN(UNIT=TEMPUNIT,FILE=FILENAME106, STATUS="unknown", form="formatted", ACCESS="APPEND")
             END IF
             WRITE(TEMPUNIT,*) NATOMS
             WRITE(TEMPUNIT,*) VNEW, IMCSTEP
             DO J1=1,NATOMS
               WRITE(TEMPUNIT,'(A,3F20.10)') 'LA  ', COORDS( 3*(J1-1)+1, MYNODE+1), 
     &          COORDS( 3*(J1-1)+2, MYNODE+1), COORDS( 3*(J1-1)+3, MYNODE+1)
             END DO
             CLOSE(TEMPUNIT)
           ENDIF
!js850> OVERLAP keyword
           IF ( OVERLAPK .AND. (MOD(IMCSTEP-1.0D0,OVERLAP_FRQ*1.0D0).EQ.0.0D0) ) THEN
              OVERLAP_COUNT = OVERLAP_COUNT +1
              CALL OVERLAP_GET_OVERLAP( COORDS(1:3*NATOMS, MYNODE+1), OVERLAP_VALA, OVERLAP_VALB, OVERLAP_VALAB)
              CALL OVERLAP_GET_OVERLAP2( COORDS(1:3*NATOMS, MYNODE+1), 
     &                  OVERLAP_VAL2A, OVERLAP_VAL2B, OVERLAP_VAL2AB, 0.35D0)
              CALL OVERLAP_GET_OVERLAP2_R( COORDS(1:3*NATOMS, MYNODE+1), 
     &                  OVERLAP_VAL2RA, OVERLAP_VAL2RB, OVERLAP_VAL2RAB, 0.35D0)
              IF ( PTMC .AND. .NOT. BSPT ) THEN
!
! Print the quenched overlap also.  If a normal PTMC run then
! quench, using MINCOORDS as scratch space. The quenched energy
! will be in POTEL because QUENCH has access to POTEL through a
! common block
!
! WARNING, QUENCH has access to COORDS through commons.mod. IF
! NORESET is false (the default) then COORDS will contain the
! quenched coordinates.  Currently this is not a problem because
! the very next step resets COORDS to X,Y,Z, but it's definitely
! not optimal.  Can fix it in a hacky way by changing NORESET
! to .TRUE., then changing it back.  What else is changed by QUENCH?
!
                 CALL MYCPU_TIME(TIMESTART)
                 NORESET_TEMP = NORESET
                 NORESET = .TRUE.
                 CALL QUENCH(.FALSE.,MYNODE+1,LBFGS_ITERATIONS,DUMMY,NDUMMY,CONVERGED,MINCOORDS(:,MYNODE+1),DOSSTATS)
                 NORESET = NORESET_TEMP
                 NQ(MYNODE+1)=NQ(MYNODE+1)+1
                 OVERLAP_TIMETOT = OVERLAP_TIMETOT + (DUMMY-TIMESTART)
                 IF (.TRUE.) THEN !print some info about the quench
                    IF (CONVERGED.NE.1) WRITE(MYUNIT, '(A)') 'bspt> WARNING - quench did not converge' 
                    WRITE(MYUNIT,'(A,F20.10,A,I5,A,G12.5,A,G20.10,A,F11.1)') 'bspt> overlap> E=',
     &                 POTEL,' steps=',LBFGS_ITERATIONS,' RMS=',RMS,' unquenched E=',VNEW,' ttot=',OVERLAP_TIMETOT
!                   WRITE(MYUNIT,'(A,F20.10,A,I5,A,G12.5,A,G20.10,A,F13.3)') ' E=',
!    &                 POTEL,' steps=',LBFGS_ITERATIONS,' RMS=',RMS,' unquenched E=',VNEW,' t=',DUMMY-TIMESTART
                 ENDIF
                 CALL OVERLAP_GET_OVERLAP( MINCOORDS(1:3*NATOMS, MYNODE+1), OVERLAP_VALQA, OVERLAP_VALQB, OVERLAP_VALQAB )
                 CALL OVERLAP_GET_OVERLAP2( MINCOORDS(1:3*NATOMS, MYNODE+1), OVERLAP_VALQ2A, 
     &                     OVERLAP_VALQ2B, OVERLAP_VALQ2AB, 0.2D0 )
                 CALL OVERLAP_GET_OVERLAP2_R( MINCOORDS(1:3*NATOMS, MYNODE+1), OVERLAP_VALQ2RA, 
     &                     OVERLAP_VALQ2RB, OVERLAP_VALQ2RAB, 0.2D0 )
                 WRITE(OVERLAP_UNIT,"(F15.1,4F20.10,14F9.4)") IMCSTEP, OVERLAP_VALAB, VNEW, OVERLAP_VALQAB, POTEL, 
     &                OVERLAP_VALA, OVERLAP_VALB,
     &                OVERLAP_VAL2A, OVERLAP_VAL2B, OVERLAP_VAL2AB,
     &                OVERLAP_VALQ2A, OVERLAP_VALQ2B, OVERLAP_VALQ2AB,
     &                OVERLAP_VAL2RA, OVERLAP_VAL2RB, OVERLAP_VAL2RAB,
     &                OVERLAP_VALQ2RA, OVERLAP_VALQ2RB, OVERLAP_VALQ2RAB
              ELSE
                 WRITE(OVERLAP_UNIT,"(F15.1,2F20.10)") IMCSTEP, OVERLAP_VALAB, VNEW
              ENDIF
              CALL FLUSH(OVERLAP_UNIT)
           ENDIF

         ENDIF
!
! If we are not calculating distances then the following lines may be unnecessary.
!
888      DO K=1,NATOMS ! COORDS have to be resaved because we have to use noreset to be able to calc distance 
            COORDS(3*(K-1)+1,MYNODE+1)=X(K)
            COORDS(3*(K-1)+2,MYNODE+1)=Y(K)
            COORDS(3*(K-1)+3,MYNODE+1)=Z(K)
         ENDDO
!
! Save PT configurations for jump move test. This is just for debugging purposes.
!
!        IF (CANDIDATELISTT) THEN
!           IF ((IMCSTEP.LE.NEQUIL+PTSTEPS).AND.(IMCSTEP.GT.NEQUIL).AND.(MOD(IMCSTEP-NEQUIL,10).EQ.0)) THEN
!              NDUMMY=(IMCSTEP-NEQUIL)/10
!              PTCAND(NDUMMY,1:3*NATOMS)=COORDS(1:3*NATOMS,MYNODE+1)
!              PTCANDE(NDUMMY)=VNEW
!              CALL POTENTIAL(PTCAND(NDUMMY,1:3*NATOMS),GRAD,DUMMY,.TRUE.,.FALSE.)
!              WRITE(MYUNIT,'(A,I8,2(A,G20.10))') 'bspt> Saving candidate number ',NDUMMY,' energy=',VNEW,' config energy=',DUMMY
!              IF (ABS(DUMMY-PTCANDE(NDUMMY)).GT.ECONV) THEN
!                 WRITE(MYUNIT,'(A,2(G20.10))') 'bspt> ERROR *** PE for saved structure and saved PE are ',DUMMY,PTCANDE(NDUMMY)
!                 STOP
!              ENDIF
!           ENDIF
!        ENDIF
!

!
! ss2029> Found it! This is where the step size is adjusted. All adjustments
! are make during equilibration (IMCSTEP<NEQUIL). Updates are
! made every NUPDATE steps based on acceptance ratio during previous
! NUPDATE steps.
!
         IF ((IMCSTEP.LE.NEQUIL).AND.(MOD(IMCSTEP,1.0D0*NUPDATE).EQ.1.0D0*0)) THEN ! update MC step size if not fixed
            WAC=1.0*IACCEPT(MYNODE)/NUPDATE
            IF (.NOT.(FIXSTEP(MYNODE+1).OR.FIXBOTH(MYNODE+1).OR.((MYNODE.LE.USERES).AND.RESERVOIRT))) THEN
               IF (WAC.LT.ACCRAT(MYNODE+1)-0.1D0) THEN
                  STEP(MYNODE+1)=STEP(MYNODE+1)*0.9D0
               ENDIF
               IF (WAC.GT.ACCRAT(MYNODE+1)+0.1D0) THEN
                  STEP(MYNODE+1)=STEP(MYNODE+1)*1.1D0
               ENDIF
            ENDIF
            IACCEPT(MYNODE)=0
            ! ss2029> commenting next line, due to mod(..,PRTFRQ) it was
            !           being printed only if PRTFRQ was a multiple of
            !           NUPDATE 
            ! IF (MOD(IMCSTEP-1.0D0,1.0D0*PRTFRQ).EQ.0) WRITE(MYUNIT,'(A,G20.10)') 'bspt> maximum step size is now ',STEP(MYNODE+1)
            
            ! 
            ! ss2029> Now printing everytime the step size is changed.
            !   The output gives an idea of the length of equilibration
            !   required to converge the step size
            ! 
            WRITE(MYUNIT, '(A,G20.10,A,G20.10,A,I6,A)') 'bspt> adjusting step-size> current step size = ', STEP(MYNODE+1) ,
     &                        ' acceptance ratio = ', WAC ,
     &                        ' over ', NUPDATE, ' steps'
         ENDIF ! step size update 

         !
         ! ss2029> print end of equilibration 
         !
         IF (IMCSTEP.EQ.NEQUIL) THEN 
               WRITE(MYUNIT, '(A)') 'bspt> ---------- Equilibration done ' 
               WRITE(MYUNIT, '(A,I6,A,F20.10,A,G20.10,A,G20.10)') 'bspt> Replica = ', MYNODE+1 , 
     &                           ' Temperature = ', TEMPTRAJ(MYNODE) ,
     &                           ' MCStep = ', IMCSTEP ,
     &                           ' MarkovEner = ', VNEW 
               WRITE(MYUNIT, '(A,G20.10,A,G20.10,A,I6,A)') 'bspt> Final step size = ', STEP(MYNODE+1) ,
     &                        '  corresponding to acceptance ratio = ', WAC , ! WAC calculated in step-adjustment block above 
     &                        ' over previous ', NUPDATE, ' steps'
               WRITE(MYUNIT, '(A,G20.10)') 'bspt>   compare with target acceptance ratio = ', ACCRAT(MYNODE+1)
               WRITE(MYUNIT, '(A)') 'bspt> ---------- Starting production run ' 
         ENDIF 


         !!!!!!!!!!!!!!!!!!! REPLICA EXCHANGE begin !!!!!!!!!!!!!!!!!!
         
         VOLD=VNEW         ! saving current Markov state 
         VMINOLD=VMINNEW   !

         ! IF ( IMCSTEP.GT.NEQUIL) THEN 
         DOSSTATSO(1:MAXIT,1:2)=DOSSTATS(1:MAXIT,1:2)
         LBFGS_ITERATIONSO=LBFGS_ITERATIONS
         E=VNEW
         IF (EXCHPROB.GT.0.0D0) CALL TRYEXCHANGE(E,X,Y,Z, 
     &                  DOSSTATS,DOSSTATSO,XO,YO,ZO,VOLD,EXCHANGEACCEPT,JLOW,
     &                  VNEW,GRAD,VNEWSAVE,VMINOLD,VMINNEW,BETA,ITRAJ,ITRAJO,NTOT, 
     &                  LBFGS_ITERATIONS,NEACCEPT,LBFGS_ITERATIONSO,QV,XDUMMY,PEINT,NCHOSEN,LASTEXDOWN,IMCSTEP)
         IF (EXCHANGEACCEPT.AND.(MYNODE.EQ.JLOW)) LASTEXUP(MYNODE)=IMCSTEP
         IF (EXCHANGEACCEPT.AND.(MYNODE.EQ.JLOW+1))  LASTEXDOWN(MYNODE)=IMCSTEP
         !  js850>At this point VOLD, VNEW  are the markov energy (perhaps changed)
         !                      X           is the markov coords
         !                      E, VNEWSAVE, XO are not determined.  They should not be used after this
         E = VNEW !js850> fix a bug here
         !ENDIF

         !!!!!!!!!!!!!!!!!!! REPLICA EXCHANGE end !!!!!!!!!!!!!!!!!!

         ! 
         ! Stats (EAV, etc) for each replica are collected within the next IF block. 
         !  Logical flow (MC->stats->PT) might be better if this block is moved up to before replica
         !  exchange is done. 
         !  todo - clean up the Q-stuff by moving it behind CALCQT flag 
         !

         IF (IMCSTEP.GT.NEQUIL) THEN 
            EAV(MYNODE)=EAV(MYNODE)+E
            EAV2(MYNODE)=EAV2(MYNODE)+E**2

            IQE=INT((E-PTEMIN)/DHISTE+1)
            IF (IQE.GT.0.AND.IQE.LT.NHISTE) THEN
               NHISTQE(IQE,MYNODE)=NHISTQE(IQE,MYNODE)+1
            ENDIF
            DO K=1,NATOMS
               Q(1,K)=X(K)
               Q(2,K)=Y(K)
               Q(3,K)=Z(K)
            ENDDO
            IF (PERIODIC.AND.CALCQT) THEN
               CALL QORDER_BLJ(Q,Q4,Q6)
            ELSE IF (CHRMMT) THEN
                 IF (ODIHET) CALL CHCALCDIHE(DIHEORDERPARAM,COORDS(1:3*NATOMS,MYNODE+1))
                 IF (OSASAT) CALL ORDER_SASA(SASAORDERPARAM,RPRO,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1))
                 IF (ORGYT) CALL CHCALCRGYR(RGYR,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),.FALSE.) 
                 IF (OEINTT) CALL CHCALCEINT(EINT,COORDS(1:3*NATOMS:3,MYNODE+1),
     1                   COORDS(2:3*NATOMS:3,MYNODE+1),COORDS(3:3*NATOMS:3,MYNODE+1),POTEL)
            ELSEIF (CALCQT) THEN
               CALL QORDER_LJ(Q,Q4,Q6)
            ENDIF
            Q4AV(MYNODE)=Q4AV(MYNODE)+Q4
            Q4AV2(MYNODE)=Q4AV2(MYNODE)+Q4**2
            Q6AV(MYNODE)=Q6AV(MYNODE)+Q6
            Q6AV2(MYNODE)=Q6AV2(MYNODE)+Q6**2

            !
            !todo move behind approriate flags - ODIHET, CHRMMT, OSASAT, ORGYT, etc 
            !
            DIHEORDERPARAM_AV(MYNODE)=DIHEORDERPARAM_AV(MYNODE)+DIHEORDERPARAM
            DIHEORDERPARAM_AV2(MYNODE)=DIHEORDERPARAM_AV2(MYNODE)+DIHEORDERPARAM**2
            SASAORDERPARAM_AV(MYNODE)=SASAORDERPARAM_AV(MYNODE)+SASAORDERPARAM
            SASAORDERPARAM_AV2(MYNODE)=SASAORDERPARAM_AV2(MYNODE)+SASAORDERPARAM**2
            RGYR_AV(MYNODE)=RGYR_AV(MYNODE)+RGYR
            RGYR_AV2(MYNODE)=RGYR_AV2(MYNODE)+RGYR**2
            EINT_AV(MYNODE)=EINT_AV(MYNODE)+EINT
            EINT_AV2(MYNODE)=EINT_AV2(MYNODE)+EINT**2
            IF (CHRMMT) THEN
               IF (ODIHET) THEN
                  IQ4=INT((DIHEORDERPARAM-DIHEORDERPARAM_MIN)/DDIHE+1)
                  IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                     NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
                  ENDIF
                  IQ6=INT((SASAORDERPARAM-SASAORDERPARAM_MIN)/DSASA+1)             
                  IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                     NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
                  ENDIF
               ELSE IF (ORGYT) THEN
                  IQ4=INT((RGYR-RGYR_MIN)/DRGYR+1)
                  IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                     NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
                  ENDIF
                  IQ6=INT((EINT-EINT_MIN)/DEINT+1)             
                  IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                     NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
                  ENDIF
               ENDIF 
            ELSE
               IQ4=INT(Q4/DQ4+1)
               IF (IQ4.GT.0.AND.IQ4.LT.NHIST) THEN
                  NHISTQ4(IQ4,MYNODE)=NHISTQ4(IQ4,MYNODE)+1
               ENDIF
               IQ6=INT(Q6/DQ6+1)             
               IF (IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                  NHISTQ6(IQ6,MYNODE)=NHISTQ6(IQ6,MYNODE)+1
               ENDIF
            ENDIF

            ! Free energy statistic
            IF (CALCQT) THEN 
              IF (IQ4.GT.0.AND.IQ4.LT.NHIST.AND.IQ6.GT.0.AND.IQ6.LT.NHIST) THEN
                 NHISTALLQ(IQ4,IQ6,MYNODE)=NHISTALLQ(IQ4,IQ6,MYNODE)+1
              ENDIF
              IF (IQ4.GT.0.AND.IQ4.LT.NHIST.AND.IQ6.GT.0.AND.IQ6.LT.NHIST.AND.
     1           IQE.GT.0.AND.IQE.LT.NHISTE) THEN
                 NHISTGRAND(IQE,IQ4,IQ6,MYNODE)=NHISTGRAND(IQE,IQ4,IQ6,MYNODE)+1
              ENDIF
            ENDIF 
              
            IENR=IENR+1
            !
            ! Dump visits histograms. 
            ! 
            IF (BSPTDUMPFRQ.GT.0) THEN
               IF (MOD(IMCSTEP,1.0D0*BSPTDUMPFRQ).EQ.0.0D0) THEN
                  WRITE (ISTR, '(I2,A1)') MYNODE+1

                  WRITE (SDUMMY, '(F15.1)') IMCSTEP

                  ! ss2029 > suffix of Visits file is IMCSTEP, but it
                  ! includes only post-eq data only i.e. (IMCSTEP-NEQUIL)
                  !  to match the two use next line 
                  ! WRITE (SDUMMY, '(I15)') INT(IMCSTEP-NEQUIL)

                  ISTR=TRIM(ADJUSTL(ISTR)) // '/Visits.his.' // TRIM(ADJUSTL(SDUMMY))
                  
                  IF (IMCSTEP.GT.NEQUIL) THEN
                     FILENAME101=TRIM(ADJUSTL(ISTR))
                     LUNIT=GETUNIT()
                     OPEN(UNIT=LUNIT,FILE=FILENAME101, STATUS="unknown", form="formatted")
                     WRITE(LUNIT, '(G20.10)') TEMPTRAJ(MYNODE)
                     WRITE(LUNIT, '(A)') 'Visits to instantaneous PE bins without quench contributions'
                     DO K=1, NENRPER
                        WRITE(LUNIT, '(G20.10,F20.1)') PTEMIN+(K-1)*PEINT,PEVISITS(K,MYNODE)
                     ENDDO
                     WRITE(LUNIT, '(A)') 'Visits to quench bins'
                     DO K=1, HBINS
                          IF (CANDIDATELISTT) THEN
                             WRITE(LUNIT, '(G20.10,F20.1,I10)') BINLABEL(K), QVISITS(K,MYNODE), CANDIDATENUM(K)
                          ELSE
                             WRITE(LUNIT, '(G20.10,F20.1)') BINLABEL(K), QVISITS(K,MYNODE)
                          ENDIF
                     ENDDO
                     CLOSE(LUNIT)
                  ENDIF

                  IF (BSPT.AND.(IMCSTEP.GT.NEQUIL+PTSTEPS).AND.(.NOT.MINDENSITYT)) THEN
                     WRITE (ISTR, '(I2,A1)') MYNODE+1
                     WRITE (SDUMMY, '(F15.1)') IMCSTEP
                     ISTR=TRIM(ADJUSTL(ISTR)) // '/Visits2.his.' // TRIM(ADJUSTL(SDUMMY))
                     FILENAME101=TRIM(ADJUSTL(ISTR))
                     LUNIT=GETUNIT()
                     OPEN(UNIT=LUNIT,FILE=FILENAME101,STATUS="unknown",FORM="UNFORMATTED")
                     WRITE(LUNIT) PEVISITS2(1:NENRPER,1:HBINS,MYNODE)
                     CLOSE(LUNIT)
                  ENDIF

                  IF (BINARY_EXAB) WRITE(MYUNIT, '(A,G15.1,A,2G15.1)') "bspt> binary_exab> tried ", 
     &               EXAB_COUNT, " accepted ", EXAB_ACC, IMCSTEP
            !
            !  Restart information
            !
                  WRITE (ISTR,'(I2)') MYNODE+1
                  FILENAME9=TRIM(ADJUSTL(ISTR)) // "/bsptrestart"
                  !js850> copy #/bsptrestart to #/bsptrestart.save
                  FILENAME10=TRIM(ADJUSTL(ISTR)) // "/bsptrestart.save"
                  SDUMMY="cp "//TRIM(ADJUSTL(FILENAME9))//" "//TRIM(ADJUSTL(FILENAME10))//" >& /dev/null"
                  CALL SYSTEM(SDUMMY)
                  LUNIT=GETUNIT()
                  OPEN(UNIT=LUNIT,FILE=FILENAME9, STATUS="unknown", form="formatted")
                  IF (PTMC .AND. .NOT. BSPT) VMINOLD = 0.D0 !TO PREVENT IT FROM PRINTING AS ***********
                  WRITE(LUNIT,'(F20.1,3G20.10,F15.1,5I15)') IMCSTEP,VOLD,VMINOLD,STEP(MYNODE+1),
     &                                                NACCEPTPT(MYNODE),NEACCEPT,NTOT,NOUTQBIN,NOUTPEBIN,NQ(MYNODE+1)
                  DO J1=1,NATOMS
                     WRITE(LUNIT,'(3G25.15)') X(J1),Y(J1),Z(J1)
                  ENDDO
                  CLOSE(LUNIT)
               ENDIF
            ENDIF ! closes IF (BSPTDUMPFRQ.GT.0) 
         ENDIF ! closes IF (IMCSTEP.GT.NEQUIL), i think .. this IF block spans 2-3 pages!  
      ENDDO 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! End of main loop over BSPT or PT steps.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
 
      WRITE (MYUNIT,'(A)') 'bspt> Exited main MC loop. ' 

! compute the averages over any plain PT steps

!     IF (PTSTEPS.GT.0) THEN
!        EAV(MYNODE)=EAV(MYNODE)/PTSTEPS
!        EAV2(MYNODE)=EAV2(MYNODE)/PTSTEPS
!        CV=(EAV2(MYNODE)-EAV(MYNODE)**2)*BETA(MYNODE)**2

!        WRITE (ISTR, '(i10)') MYNODE+1
!        FILENAME3=trim(adjustl(istr)) // "/T.Ev.Cv.Ev2.Steps"
!        LUNIT=GETUNIT()
!        OPEN(UNIT=LUNIT,FILE=FILENAME3, STATUS="unknown", form="formatted")
!        IF (CHRMMT) THEN
!           WRITE(LUNIT,'(6G20.10)') TEMPTRAJ(MYNODE),TEMPTRAJ(MYNODE)/0.001987, 
!    &                                EAV(MYNODE), CV, EAV2(MYNODE),PTSTEPS
!        ELSE
!           WRITE(LUNIT,'(5G20.10)') TEMPTRAJ(MYNODE),EAV(MYNODE),CV, EAV2(MYNODE),PTSTEPS
!        ENDIF
!        CALL FLUSH(LUNIT)
!        CLOSE(LUNIT)
!     ENDIF

      Q4AV(MYNODE)=Q4AV(MYNODE)/PTSTEPS
      Q6AV(MYNODE)=Q6AV(MYNODE)/PTSTEPS
      Q4AV2(MYNODE)=Q4AV2(MYNODE)/PTSTEPS
      Q6AV2(MYNODE)=Q6AV2(MYNODE)/PTSTEPS
      DIHEORDERPARAM_AV(MYNODE)=DIHEORDERPARAM_AV(MYNODE)/PTSTEPS
      SASAORDERPARAM_AV(MYNODE)=SASAORDERPARAM_AV(MYNODE)/PTSTEPS
      DIHEORDERPARAM_AV2(MYNODE)=DIHEORDERPARAM_AV2(MYNODE)/PTSTEPS
      SASAORDERPARAM_AV2(MYNODE)=SASAORDERPARAM_AV2(MYNODE)/PTSTEPS
      RGYR_AV(MYNODE)=RGYR_AV(MYNODE)/PTSTEPS
      EINT_AV(MYNODE)=EINT_AV(MYNODE)/PTSTEPS
      RGYR_AV2(MYNODE)=RGYR_AV2(MYNODE)/PTSTEPS
      EINT_AV2(MYNODE)=EINT_AV2(MYNODE)/PTSTEPS
      FQ4=SQRT(Q4AV2(MYNODE)-Q4AV(MYNODE)**2)
      FQ6=SQRT(Q6AV2(MYNODE)-Q6AV(MYNODE)**2)
      IF (BINARY .OR. SOFT_SPHERE) THEN  
         FILENAME4="T.Q4Av.Q6Av.Q4Av2.Q6Av2.Steps."//trim(adjustl(istr))
         LUNIT=GETUNIT()
         OPEN(UNIT=LUNIT,FILE=FILENAME4, STATUS="unknown", form="formatted")
         WRITE(LUNIT,'(6G20.10)') TEMPTRAJ(MYNODE), Q4AV(MYNODE), Q6AV(MYNODE), Q4AV2(MYNODE),Q6AV2(MYNODE), PTSTEPS
         CLOSE(LUNIT)
      ENDIF
      IF (CHRMMT) THEN 
         IF (ODIHET) THEN 
            FILENAME4="T.DiheAv.SasaAv.DiheAv2.SasaAv2.Steps."//trim(adjustl(istr))
            LUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME4, STATUS="unknown", form="formatted")
            WRITE(LUNIT,'(6G20.10)') TEMPTRAJ(MYNODE), DIHEORDERPARAM_AV(MYNODE), 
     &              SASAORDERPARAM_AV(MYNODE), DIHEORDERPARAM_AV2(MYNODE),SASAORDERPARAM_AV2(MYNODE), PTSTEPS
            CLOSE(LUNIT)
            ELSE IF (ORGYT) THEN
            FILENAME4="T.RgyrAv.EintAv.RgyrAv2.Eint2.Steps."//trim(adjustl(istr))
            LUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME4, STATUS="unknown", form="formatted")
            WRITE(LUNIT,'(6G20.10)') TEMPTRAJ(MYNODE), RGYR_AV(MYNODE),EINT_AV(MYNODE), RGYR_AV2(MYNODE),  
     &              EINT_AV2(MYNODE), PTSTEPS
            CLOSE(LUNIT)
         ENDIF
      ENDIF

!     FILENAME5=TRIM(ADJUSTL(ISTR)) // '/profile_E'
!     LUNIT=GETUNIT()
!     OPEN(UNIT=LUNIT,FILE=FILENAME5, STATUS="unknown", form="formatted")
!     DO K=1,NHISTE
!        WRITE(LUNIT,'(2G20.10)') PTEMIN+(K-1)*DHISTE,NHISTQE(K,MYNODE)
!     ENDDO
!     CLOSE(LUNIT)

      IF (BINARY .OR. SOFT_SPHERE) THEN  
         FILENAME6="profile_Q4."//trim(adjustl(istr))
         FILENAME7="profile_Q6."//trim(adjustl(istr))
         LUNIT=GETUNIT()
         TEMPUNIT=GETUNIT()
         OPEN(UNIT=LUNIT,FILE=FILENAME6, STATUS="unknown", form="formatted")
         OPEN(UNIT=TEMPUNIT,FILE=FILENAME7, STATUS="unknown", form="formatted")
         DO K=1,NHIST
            WRITE(LUNIT,'(2G20.10)') (K-1)*DQ4,NHISTQ4(K,MYNODE)
            WRITE(TEMPUNIT,'(2G20.10)') (K-1)*DQ6,NHISTQ6(K,MYNODE)
         ENDDO
         CLOSE(LUNIT)
         CLOSE(TEMPUNIT)
      ELSE IF (CHRMMT) THEN
         IF (ODIHET) THEN
            FILENAME6="profile_dihe."//trim(adjustl(istr))
            FILENAME7="profile_sasa."//trim(adjustl(istr))
            LUNIT=GETUNIT()
            TEMPUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME6, STATUS="unknown", form="formatted")
            OPEN(UNIT=TEMPUNIT,FILE=FILENAME7, STATUS="unknown", form="formatted")
            DO K=1,NHIST
               WRITE(LUNIT,'(2G20.10)') diheorderparam_min+(K-1)*Ddihe,NHISTQ4(K,MYNODE)
               WRITE(TEMPUNIT,'(2G20.10)') SASAorderparam_min+(K-1)*Dsasa,NHISTQ6(K,MYNODE)
            ENDDO
            CLOSE(LUNIT)
            CLOSE(TEMPUNIT)
         ELSE IF (ORGYT) THEN
            FILENAME6="profile_rgyr."//trim(adjustl(istr))
            FILENAME7="profile_eint."//trim(adjustl(istr))
            LUNIT=GETUNIT()
            TEMPUNIT=GETUNIT()
            OPEN(UNIT=LUNIT,FILE=FILENAME6, STATUS="unknown", form="formatted")
            OPEN(UNIT=TEMPUNIT,FILE=FILENAME7, STATUS="unknown", form="formatted")
            DO K=1,NHIST
               WRITE(LUNIT,'(2G20.10)') rgyr_min+(K-1)*Drgyr,NHISTQ4(K,MYNODE)
               WRITE(TEMPUNIT,'(2G20.10)') eint_min+(K-1)*Deint,NHISTQ6(K,MYNODE)
            ENDDO
            CLOSE(LUNIT)
            CLOSE(TEMPUNIT)
         ENDIF
      ENDIF
!
! ss2029> close dumpenergy file
!
      IF ( PTMCDUMPENERT ) CLOSE(FILENAME_ENER_LUNIT) 
!
! Printing summary
!
      IF (OVERLAPK) WRITE(MYUNIT, '(A,3G15.3)') "bspt> overlap> summary ", OVERLAP_TIMETOT, 
     &          OVERLAP_COUNT, OVERLAP_TIMETOT/OVERLAP_COUNT
      IF (BINARY_EXAB) WRITE(MYUNIT, '(A,G15.1,A,G15.1)') "bspt> binary_exab> tried ", EXAB_COUNT, " accepted ", EXAB_ACC
      WRITE(MYUNIT, '(A,F15.1,A,G15.1,A,F15.5,A)') 'bspt> ',NACCEPTPT(MYNODE), ' steps accepted out of ', 
     &            PTSTEPS+NEQUIL+NQUENCH, ' i.e. ',NACCEPTPT(MYNODE)*100.0D0/(PTSTEPS+NEQUIL+NQUENCH),'%'
      WRITE(MYUNIT, '(A,G20.10)') 'bspt> Final stepsize ', STEP(MYNODE+1)
      WRITE(MYUNIT, '(A,G20.10,A,2G20.10,A)') 'bspt> ',NEACCEPT, ' PT exchanges accepted out of ', 
     &                                                 NTOT,NEACCEPT*100.0D0/(1.0D0*MAX(1,NTOT)),' %'
      IF (BSPT) WRITE(MYUNIT, '(A,G20.10,A,G20.10,A)') 'bspt> ',NOUTQBIN, ' quenches outside quench bin range: ',
     &                                      NOUTQBIN*100.0D0/(NQUENCH),' %'
      WRITE(MYUNIT, '(A,I8,A,G20.10,A)') 'bspt> ',NOUTPEBIN, ' potential energies outside bin range: ',
     &                                      NOUTPEBIN*100.0D0/(PTSTEPS+NEQUIL+NQUENCH),' %'
      IF (BSPT) THEN
         IF (PERCOLATET) THEN
            IF (MINDENSITYT) THEN
               WRITE(MYUNIT, '(A,G20.10,A,G20.10,A)') 'bspt> ',XOUT, ' steps failed to produce a percolating system: ',
     &                                         XOUT*100.0D0/(NQUENCH+NEQUIL),' %'
            ELSE
               WRITE(MYUNIT, '(A,G20.10,A,G20.10,A)') 'bspt> ',XOUT, ' steps failed to produce a percolating system: ',
     &                                            XOUT*100.0D0/(NQUENCH),' %'
            ENDIF
         ELSE
            IF (MINDENSITYT) THEN
               WRITE(MYUNIT, '(A,G20.10,A,G20.10,A)') 'bspt> ',XOUT, ' steps had an atom outside the container: ',
     &                                            XOUT*100.0D0/(NQUENCH+NEQUIL),' %'
            ELSE
               WRITE(MYUNIT, '(A,G20.10,A,G20.10,A)') 'bspt> ',XOUT, ' steps had an atom outside the container: ',
     &                                            XOUT*100.0D0/(NQUENCH),' %'
            ENDIF
         ENDIF
      ENDIF
      WRITE(MYUNIT, '(A,I8)') 'bspt> total number of quenches actually required=',NQ(MYNODE+1)

      DO K=1,NATOMS
         Q(1,K)=X(K)
         Q(2,K)=Y(K)
         Q(3,K)=Z(K)
      ENDDO
      IF (PERIODIC) THEN
         CALL QORDER_BLJ(Q,Q4,Q6)
      ELSE
         CALL QORDER_LJ(Q,Q4,Q6)
      ENDIF
!
! Dump visits histograms. Energies are written for the middle of the bins.
! This is the really important part!
!
      WRITE (ISTR, '(i10)') MYNODE +1
      FILENAME101=trim(adjustl(istr)) // "/Visits.his"
      LUNIT=GETUNIT()
      OPEN(UNIT=LUNIT,FILE=FILENAME101, STATUS="unknown", form="formatted")
      WRITE(LUNIT, '(G20.10)') TEMPTRAJ(MYNODE)
      WRITE(LUNIT, '(A)') 'Visits to instantaneous PE bins without quench contributions'
      DO K=1, NENRPER
         WRITE(LUNIT, '(G20.10,F20.1)') PTEMIN+(K-1)*PEINT,PEVISITS(K,MYNODE)
      ENDDO
      WRITE(LUNIT, '(A)') 'Visits to quench bins'
      DO K=1, HBINS
         IF (CANDIDATELISTT) THEN
            WRITE(LUNIT, '(G20.10,F20.1,I10)') BINLABEL(K), QVISITS(K,MYNODE), CANDIDATENUM(K)
         ELSE
            WRITE(LUNIT, '(G20.10,F20.1)') BINLABEL(K), QVISITS(K,MYNODE)
         ENDIF
      ENDDO
      CLOSE(LUNIT)

      IF (BSPT.AND.(.NOT.MINDENSITYT)) THEN
         FILENAME101=trim(adjustl(istr)) // "/Visits2.his"
         LUNIT=GETUNIT()
         OPEN(UNIT=LUNIT,FILE=FILENAME101,STATUS="unknown",FORM="UNFORMATTED")
         WRITE(LUNIT) PEVISITS2(1:NENRPER,1:HBINS,MYNODE)
         CLOSE(LUNIT)
      ENDIF
!
! Dump final restart information.
!
      WRITE (ISTR,'(I2)') MYNODE+1
      FILENAME9=TRIM(ADJUSTL(ISTR)) // "/bsptrestart"
      !js850> copy #/bsptrestart to #/bsptrestart.save
      FILENAME10=TRIM(ADJUSTL(ISTR)) // "/bsptrestart.save"
      SDUMMY="cp "//TRIM(ADJUSTL(FILENAME9))//" "//TRIM(ADJUSTL(FILENAME10))
      CALL SYSTEM(SDUMMY)
      LUNIT=GETUNIT()
      OPEN(UNIT=LUNIT,FILE=FILENAME9, STATUS="unknown", form="formatted")
      IF (PTMC .AND. .NOT. BSPT) VMINOLD = 0.D0 !TO PREVENT IT FROM PRINTING AS ***********
      WRITE(LUNIT,'(F20.1,3G20.10,F15.1,5I10)') IMCSTEP,VOLD,VMINOLD,STEP(MYNODE+1),
     &                                          NACCEPTPT(MYNODE),NEACCEPT,NTOT,NOUTQBIN,NOUTPEBIN,NQ(MYNODE+1)
      DO J1=1,NATOMS
         WRITE(LUNIT,'(3G25.15)') X(J1),Y(J1),Z(J1)
      ENDDO
      CLOSE(LUNIT)

      IF (OVERLAPK) CLOSE(OVERLAP_UNIT)

      RETURN
#else
      RETURN
#endif
      END SUBROUTINE PTBASINSAMPLING
